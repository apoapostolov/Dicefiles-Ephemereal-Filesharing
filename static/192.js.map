{"version":3,"file":"192.js?v=6985ee01fb648a203c06","mappings":"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","sources":["webpack:///../node_modules/@lingo-reader/shared/node_modules/sax/lib/sax.js","webpack:///../node_modules/path-browserify/index.js","webpack:///../node_modules/fflate/esm/browser.js","webpack:///../node_modules/@lingo-reader/shared/dist/index.browser.mjs","webpack:///../node_modules/@lingo-reader/mobi-parser/dist/index.browser.mjs"],"sourcesContent":[";(function (sax) {\n  // wrapper for non-node envs\n  sax.parser = function (strict, opt) {\n    return new SAXParser(strict, opt)\n  }\n  sax.SAXParser = SAXParser\n  sax.SAXStream = SAXStream\n  sax.createStream = createStream\n\n  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.\n  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),\n  // since that's the earliest that a buffer overrun could occur.  This way, checks are\n  // as rare as required, but as often as necessary to ensure never crossing this bound.\n  // Furthermore, buffers are only tested at most once per write(), so passing a very\n  // large string into write() might have undesirable effects, but this is manageable by\n  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme\n  // edge case, result in creating at most one complete copy of the string passed in.\n  // Set to Infinity to have unlimited buffers.\n  sax.MAX_BUFFER_LENGTH = 64 * 1024\n\n  var buffers = [\n    'comment',\n    'sgmlDecl',\n    'textNode',\n    'tagName',\n    'doctype',\n    'procInstName',\n    'procInstBody',\n    'entity',\n    'attribName',\n    'attribValue',\n    'cdata',\n    'script',\n  ]\n\n  sax.EVENTS = [\n    'text',\n    'processinginstruction',\n    'sgmldeclaration',\n    'doctype',\n    'comment',\n    'opentagstart',\n    'attribute',\n    'opentag',\n    'closetag',\n    'opencdata',\n    'cdata',\n    'closecdata',\n    'error',\n    'end',\n    'ready',\n    'script',\n    'opennamespace',\n    'closenamespace',\n  ]\n\n  function SAXParser(strict, opt) {\n    if (!(this instanceof SAXParser)) {\n      return new SAXParser(strict, opt)\n    }\n\n    var parser = this\n    clearBuffers(parser)\n    parser.q = parser.c = ''\n    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH\n    parser.opt = opt || {}\n    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags\n    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase'\n    parser.tags = []\n    parser.closed = parser.closedRoot = parser.sawRoot = false\n    parser.tag = parser.error = null\n    parser.strict = !!strict\n    parser.noscript = !!(strict || parser.opt.noscript)\n    parser.state = S.BEGIN\n    parser.strictEntities = parser.opt.strictEntities\n    parser.ENTITIES =\n      parser.strictEntities ?\n        Object.create(sax.XML_ENTITIES)\n      : Object.create(sax.ENTITIES)\n    parser.attribList = []\n\n    // namespaces form a prototype chain.\n    // it always points at the current tag,\n    // which protos to its parent tag.\n    if (parser.opt.xmlns) {\n      parser.ns = Object.create(rootNS)\n    }\n\n    // disallow unquoted attribute values if not otherwise configured\n    // and strict mode is true\n    if (parser.opt.unquotedAttributeValues === undefined) {\n      parser.opt.unquotedAttributeValues = !strict\n    }\n\n    // mostly just for error reporting\n    parser.trackPosition = parser.opt.position !== false\n    if (parser.trackPosition) {\n      parser.position = parser.line = parser.column = 0\n    }\n    emit(parser, 'onready')\n  }\n\n  if (!Object.create) {\n    Object.create = function (o) {\n      function F() {}\n      F.prototype = o\n      var newf = new F()\n      return newf\n    }\n  }\n\n  if (!Object.keys) {\n    Object.keys = function (o) {\n      var a = []\n      for (var i in o) if (o.hasOwnProperty(i)) a.push(i)\n      return a\n    }\n  }\n\n  function checkBufferLength(parser) {\n    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)\n    var maxActual = 0\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      var len = parser[buffers[i]].length\n      if (len > maxAllowed) {\n        // Text/cdata nodes can get big, and since they're buffered,\n        // we can get here under normal conditions.\n        // Avoid issues by emitting the text node now,\n        // so at least it won't get any bigger.\n        switch (buffers[i]) {\n          case 'textNode':\n            closeText(parser)\n            break\n\n          case 'cdata':\n            emitNode(parser, 'oncdata', parser.cdata)\n            parser.cdata = ''\n            break\n\n          case 'script':\n            emitNode(parser, 'onscript', parser.script)\n            parser.script = ''\n            break\n\n          default:\n            error(parser, 'Max buffer length exceeded: ' + buffers[i])\n        }\n      }\n      maxActual = Math.max(maxActual, len)\n    }\n    // schedule the next check for the earliest possible buffer overrun.\n    var m = sax.MAX_BUFFER_LENGTH - maxActual\n    parser.bufferCheckPosition = m + parser.position\n  }\n\n  function clearBuffers(parser) {\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      parser[buffers[i]] = ''\n    }\n  }\n\n  function flushBuffers(parser) {\n    closeText(parser)\n    if (parser.cdata !== '') {\n      emitNode(parser, 'oncdata', parser.cdata)\n      parser.cdata = ''\n    }\n    if (parser.script !== '') {\n      emitNode(parser, 'onscript', parser.script)\n      parser.script = ''\n    }\n  }\n\n  SAXParser.prototype = {\n    end: function () {\n      end(this)\n    },\n    write: write,\n    resume: function () {\n      this.error = null\n      return this\n    },\n    close: function () {\n      return this.write(null)\n    },\n    flush: function () {\n      flushBuffers(this)\n    },\n  }\n\n  var Stream\n  try {\n    Stream = require('stream').Stream\n  } catch (ex) {\n    Stream = function () {}\n  }\n  if (!Stream) Stream = function () {}\n\n  var streamWraps = sax.EVENTS.filter(function (ev) {\n    return ev !== 'error' && ev !== 'end'\n  })\n\n  function createStream(strict, opt) {\n    return new SAXStream(strict, opt)\n  }\n\n  function SAXStream(strict, opt) {\n    if (!(this instanceof SAXStream)) {\n      return new SAXStream(strict, opt)\n    }\n\n    Stream.apply(this)\n\n    this._parser = new SAXParser(strict, opt)\n    this.writable = true\n    this.readable = true\n\n    var me = this\n\n    this._parser.onend = function () {\n      me.emit('end')\n    }\n\n    this._parser.onerror = function (er) {\n      me.emit('error', er)\n\n      // if didn't throw, then means error was handled.\n      // go ahead and clear error, so we can write again.\n      me._parser.error = null\n    }\n\n    this._decoder = null\n\n    streamWraps.forEach(function (ev) {\n      Object.defineProperty(me, 'on' + ev, {\n        get: function () {\n          return me._parser['on' + ev]\n        },\n        set: function (h) {\n          if (!h) {\n            me.removeAllListeners(ev)\n            me._parser['on' + ev] = h\n            return h\n          }\n          me.on(ev, h)\n        },\n        enumerable: true,\n        configurable: false,\n      })\n    })\n  }\n\n  SAXStream.prototype = Object.create(Stream.prototype, {\n    constructor: {\n      value: SAXStream,\n    },\n  })\n\n  SAXStream.prototype.write = function (data) {\n    if (\n      typeof Buffer === 'function' &&\n      typeof Buffer.isBuffer === 'function' &&\n      Buffer.isBuffer(data)\n    ) {\n      if (!this._decoder) {\n        this._decoder = new TextDecoder('utf8')\n      }\n      data = this._decoder.decode(data, { stream: true })\n    }\n\n    this._parser.write(data.toString())\n    this.emit('data', data)\n    return true\n  }\n\n  SAXStream.prototype.end = function (chunk) {\n    if (chunk && chunk.length) {\n      this.write(chunk)\n    }\n    // Flush any remaining decoded data from the TextDecoder\n    if (this._decoder) {\n      var remaining = this._decoder.decode()\n      if (remaining) {\n        this._parser.write(remaining)\n        this.emit('data', remaining)\n      }\n    }\n    this._parser.end()\n    return true\n  }\n\n  SAXStream.prototype.on = function (ev, handler) {\n    var me = this\n    if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {\n      me._parser['on' + ev] = function () {\n        var args =\n          arguments.length === 1 ?\n            [arguments[0]]\n          : Array.apply(null, arguments)\n        args.splice(0, 0, ev)\n        me.emit.apply(me, args)\n      }\n    }\n\n    return Stream.prototype.on.call(me, ev, handler)\n  }\n\n  // this really needs to be replaced with character classes.\n  // XML allows all manner of ridiculous numbers and digits.\n  var CDATA = '[CDATA['\n  var DOCTYPE = 'DOCTYPE'\n  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace'\n  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/'\n  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }\n\n  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar\n  // This implementation works on strings, a single character at a time\n  // as such, it cannot ever support astral-plane characters (10000-EFFFF)\n  // without a significant breaking change to either this  parser, or the\n  // JavaScript language.  Implementation of an emoji-capable xml parser\n  // is left as an exercise for the reader.\n  var nameStart =\n    /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/\n\n  var nameBody =\n    /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/\n\n  var entityStart =\n    /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/\n  var entityBody =\n    /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/\n\n  function isWhitespace(c) {\n    return c === ' ' || c === '\\n' || c === '\\r' || c === '\\t'\n  }\n\n  function isQuote(c) {\n    return c === '\"' || c === \"'\"\n  }\n\n  function isAttribEnd(c) {\n    return c === '>' || isWhitespace(c)\n  }\n\n  function isMatch(regex, c) {\n    return regex.test(c)\n  }\n\n  function notMatch(regex, c) {\n    return !isMatch(regex, c)\n  }\n\n  var S = 0\n  sax.STATE = {\n    BEGIN: S++, // leading byte order mark or whitespace\n    BEGIN_WHITESPACE: S++, // leading whitespace\n    TEXT: S++, // general stuff\n    TEXT_ENTITY: S++, // &amp and such.\n    OPEN_WAKA: S++, // <\n    SGML_DECL: S++, // <!BLARG\n    SGML_DECL_QUOTED: S++, // <!BLARG foo \"bar\n    DOCTYPE: S++, // <!DOCTYPE\n    DOCTYPE_QUOTED: S++, // <!DOCTYPE \"//blah\n    DOCTYPE_DTD: S++, // <!DOCTYPE \"//blah\" [ ...\n    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE \"//blah\" [ \"foo\n    COMMENT_STARTING: S++, // <!-\n    COMMENT: S++, // <!--\n    COMMENT_ENDING: S++, // <!-- blah -\n    COMMENT_ENDED: S++, // <!-- blah --\n    CDATA: S++, // <![CDATA[ something\n    CDATA_ENDING: S++, // ]\n    CDATA_ENDING_2: S++, // ]]\n    PROC_INST: S++, // <?hi\n    PROC_INST_BODY: S++, // <?hi there\n    PROC_INST_ENDING: S++, // <?hi \"there\" ?\n    OPEN_TAG: S++, // <strong\n    OPEN_TAG_SLASH: S++, // <strong /\n    ATTRIB: S++, // <a\n    ATTRIB_NAME: S++, // <a foo\n    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _\n    ATTRIB_VALUE: S++, // <a foo=\n    ATTRIB_VALUE_QUOTED: S++, // <a foo=\"bar\n    ATTRIB_VALUE_CLOSED: S++, // <a foo=\"bar\"\n    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar\n    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar=\"&quot;\"\n    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot\n    CLOSE_TAG: S++, // </a\n    CLOSE_TAG_SAW_WHITE: S++, // </a   >\n    SCRIPT: S++, // <script> ...\n    SCRIPT_ENDING: S++, // <script> ... <\n  }\n\n  sax.XML_ENTITIES = {\n    amp: '&',\n    gt: '>',\n    lt: '<',\n    quot: '\"',\n    apos: \"'\",\n  }\n\n  sax.ENTITIES = {\n    amp: '&',\n    gt: '>',\n    lt: '<',\n    quot: '\"',\n    apos: \"'\",\n    AElig: 198,\n    Aacute: 193,\n    Acirc: 194,\n    Agrave: 192,\n    Aring: 197,\n    Atilde: 195,\n    Auml: 196,\n    Ccedil: 199,\n    ETH: 208,\n    Eacute: 201,\n    Ecirc: 202,\n    Egrave: 200,\n    Euml: 203,\n    Iacute: 205,\n    Icirc: 206,\n    Igrave: 204,\n    Iuml: 207,\n    Ntilde: 209,\n    Oacute: 211,\n    Ocirc: 212,\n    Ograve: 210,\n    Oslash: 216,\n    Otilde: 213,\n    Ouml: 214,\n    THORN: 222,\n    Uacute: 218,\n    Ucirc: 219,\n    Ugrave: 217,\n    Uuml: 220,\n    Yacute: 221,\n    aacute: 225,\n    acirc: 226,\n    aelig: 230,\n    agrave: 224,\n    aring: 229,\n    atilde: 227,\n    auml: 228,\n    ccedil: 231,\n    eacute: 233,\n    ecirc: 234,\n    egrave: 232,\n    eth: 240,\n    euml: 235,\n    iacute: 237,\n    icirc: 238,\n    igrave: 236,\n    iuml: 239,\n    ntilde: 241,\n    oacute: 243,\n    ocirc: 244,\n    ograve: 242,\n    oslash: 248,\n    otilde: 245,\n    ouml: 246,\n    szlig: 223,\n    thorn: 254,\n    uacute: 250,\n    ucirc: 251,\n    ugrave: 249,\n    uuml: 252,\n    yacute: 253,\n    yuml: 255,\n    copy: 169,\n    reg: 174,\n    nbsp: 160,\n    iexcl: 161,\n    cent: 162,\n    pound: 163,\n    curren: 164,\n    yen: 165,\n    brvbar: 166,\n    sect: 167,\n    uml: 168,\n    ordf: 170,\n    laquo: 171,\n    not: 172,\n    shy: 173,\n    macr: 175,\n    deg: 176,\n    plusmn: 177,\n    sup1: 185,\n    sup2: 178,\n    sup3: 179,\n    acute: 180,\n    micro: 181,\n    para: 182,\n    middot: 183,\n    cedil: 184,\n    ordm: 186,\n    raquo: 187,\n    frac14: 188,\n    frac12: 189,\n    frac34: 190,\n    iquest: 191,\n    times: 215,\n    divide: 247,\n    OElig: 338,\n    oelig: 339,\n    Scaron: 352,\n    scaron: 353,\n    Yuml: 376,\n    fnof: 402,\n    circ: 710,\n    tilde: 732,\n    Alpha: 913,\n    Beta: 914,\n    Gamma: 915,\n    Delta: 916,\n    Epsilon: 917,\n    Zeta: 918,\n    Eta: 919,\n    Theta: 920,\n    Iota: 921,\n    Kappa: 922,\n    Lambda: 923,\n    Mu: 924,\n    Nu: 925,\n    Xi: 926,\n    Omicron: 927,\n    Pi: 928,\n    Rho: 929,\n    Sigma: 931,\n    Tau: 932,\n    Upsilon: 933,\n    Phi: 934,\n    Chi: 935,\n    Psi: 936,\n    Omega: 937,\n    alpha: 945,\n    beta: 946,\n    gamma: 947,\n    delta: 948,\n    epsilon: 949,\n    zeta: 950,\n    eta: 951,\n    theta: 952,\n    iota: 953,\n    kappa: 954,\n    lambda: 955,\n    mu: 956,\n    nu: 957,\n    xi: 958,\n    omicron: 959,\n    pi: 960,\n    rho: 961,\n    sigmaf: 962,\n    sigma: 963,\n    tau: 964,\n    upsilon: 965,\n    phi: 966,\n    chi: 967,\n    psi: 968,\n    omega: 969,\n    thetasym: 977,\n    upsih: 978,\n    piv: 982,\n    ensp: 8194,\n    emsp: 8195,\n    thinsp: 8201,\n    zwnj: 8204,\n    zwj: 8205,\n    lrm: 8206,\n    rlm: 8207,\n    ndash: 8211,\n    mdash: 8212,\n    lsquo: 8216,\n    rsquo: 8217,\n    sbquo: 8218,\n    ldquo: 8220,\n    rdquo: 8221,\n    bdquo: 8222,\n    dagger: 8224,\n    Dagger: 8225,\n    bull: 8226,\n    hellip: 8230,\n    permil: 8240,\n    prime: 8242,\n    Prime: 8243,\n    lsaquo: 8249,\n    rsaquo: 8250,\n    oline: 8254,\n    frasl: 8260,\n    euro: 8364,\n    image: 8465,\n    weierp: 8472,\n    real: 8476,\n    trade: 8482,\n    alefsym: 8501,\n    larr: 8592,\n    uarr: 8593,\n    rarr: 8594,\n    darr: 8595,\n    harr: 8596,\n    crarr: 8629,\n    lArr: 8656,\n    uArr: 8657,\n    rArr: 8658,\n    dArr: 8659,\n    hArr: 8660,\n    forall: 8704,\n    part: 8706,\n    exist: 8707,\n    empty: 8709,\n    nabla: 8711,\n    isin: 8712,\n    notin: 8713,\n    ni: 8715,\n    prod: 8719,\n    sum: 8721,\n    minus: 8722,\n    lowast: 8727,\n    radic: 8730,\n    prop: 8733,\n    infin: 8734,\n    ang: 8736,\n    and: 8743,\n    or: 8744,\n    cap: 8745,\n    cup: 8746,\n    int: 8747,\n    there4: 8756,\n    sim: 8764,\n    cong: 8773,\n    asymp: 8776,\n    ne: 8800,\n    equiv: 8801,\n    le: 8804,\n    ge: 8805,\n    sub: 8834,\n    sup: 8835,\n    nsub: 8836,\n    sube: 8838,\n    supe: 8839,\n    oplus: 8853,\n    otimes: 8855,\n    perp: 8869,\n    sdot: 8901,\n    lceil: 8968,\n    rceil: 8969,\n    lfloor: 8970,\n    rfloor: 8971,\n    lang: 9001,\n    rang: 9002,\n    loz: 9674,\n    spades: 9824,\n    clubs: 9827,\n    hearts: 9829,\n    diams: 9830,\n  }\n\n  Object.keys(sax.ENTITIES).forEach(function (key) {\n    var e = sax.ENTITIES[key]\n    var s = typeof e === 'number' ? String.fromCharCode(e) : e\n    sax.ENTITIES[key] = s\n  })\n\n  for (var s in sax.STATE) {\n    sax.STATE[sax.STATE[s]] = s\n  }\n\n  // shorthand\n  S = sax.STATE\n\n  function emit(parser, event, data) {\n    parser[event] && parser[event](data)\n  }\n\n  function emitNode(parser, nodeType, data) {\n    if (parser.textNode) closeText(parser)\n    emit(parser, nodeType, data)\n  }\n\n  function closeText(parser) {\n    parser.textNode = textopts(parser.opt, parser.textNode)\n    if (parser.textNode) emit(parser, 'ontext', parser.textNode)\n    parser.textNode = ''\n  }\n\n  function textopts(opt, text) {\n    if (opt.trim) text = text.trim()\n    if (opt.normalize) text = text.replace(/\\s+/g, ' ')\n    return text\n  }\n\n  function error(parser, er) {\n    closeText(parser)\n    if (parser.trackPosition) {\n      er +=\n        '\\nLine: ' +\n        parser.line +\n        '\\nColumn: ' +\n        parser.column +\n        '\\nChar: ' +\n        parser.c\n    }\n    er = new Error(er)\n    parser.error = er\n    emit(parser, 'onerror', er)\n    return parser\n  }\n\n  function end(parser) {\n    if (parser.sawRoot && !parser.closedRoot)\n      strictFail(parser, 'Unclosed root tag')\n    if (\n      parser.state !== S.BEGIN &&\n      parser.state !== S.BEGIN_WHITESPACE &&\n      parser.state !== S.TEXT\n    ) {\n      error(parser, 'Unexpected end')\n    }\n    closeText(parser)\n    parser.c = ''\n    parser.closed = true\n    emit(parser, 'onend')\n    SAXParser.call(parser, parser.strict, parser.opt)\n    return parser\n  }\n\n  function strictFail(parser, message) {\n    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {\n      throw new Error('bad call to strictFail')\n    }\n    if (parser.strict) {\n      error(parser, message)\n    }\n  }\n\n  function newTag(parser) {\n    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()\n    var parent = parser.tags[parser.tags.length - 1] || parser\n    var tag = (parser.tag = { name: parser.tagName, attributes: {} })\n\n    // will be overridden if tag contails an xmlns=\"foo\" or xmlns:foo=\"bar\"\n    if (parser.opt.xmlns) {\n      tag.ns = parent.ns\n    }\n    parser.attribList.length = 0\n    emitNode(parser, 'onopentagstart', tag)\n  }\n\n  function qname(name, attribute) {\n    var i = name.indexOf(':')\n    var qualName = i < 0 ? ['', name] : name.split(':')\n    var prefix = qualName[0]\n    var local = qualName[1]\n\n    // <x \"xmlns\"=\"http://foo\">\n    if (attribute && name === 'xmlns') {\n      prefix = 'xmlns'\n      local = ''\n    }\n\n    return { prefix: prefix, local: local }\n  }\n\n  function attrib(parser) {\n    if (!parser.strict) {\n      parser.attribName = parser.attribName[parser.looseCase]()\n    }\n\n    if (\n      parser.attribList.indexOf(parser.attribName) !== -1 ||\n      parser.tag.attributes.hasOwnProperty(parser.attribName)\n    ) {\n      parser.attribName = parser.attribValue = ''\n      return\n    }\n\n    if (parser.opt.xmlns) {\n      var qn = qname(parser.attribName, true)\n      var prefix = qn.prefix\n      var local = qn.local\n\n      if (prefix === 'xmlns') {\n        // namespace binding attribute. push the binding into scope\n        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {\n          strictFail(\n            parser,\n            'xml: prefix must be bound to ' +\n              XML_NAMESPACE +\n              '\\n' +\n              'Actual: ' +\n              parser.attribValue\n          )\n        } else if (\n          local === 'xmlns' &&\n          parser.attribValue !== XMLNS_NAMESPACE\n        ) {\n          strictFail(\n            parser,\n            'xmlns: prefix must be bound to ' +\n              XMLNS_NAMESPACE +\n              '\\n' +\n              'Actual: ' +\n              parser.attribValue\n          )\n        } else {\n          var tag = parser.tag\n          var parent = parser.tags[parser.tags.length - 1] || parser\n          if (tag.ns === parent.ns) {\n            tag.ns = Object.create(parent.ns)\n          }\n          tag.ns[local] = parser.attribValue\n        }\n      }\n\n      // defer onattribute events until all attributes have been seen\n      // so any new bindings can take effect. preserve attribute order\n      // so deferred events can be emitted in document order\n      parser.attribList.push([parser.attribName, parser.attribValue])\n    } else {\n      // in non-xmlns mode, we can emit the event right away\n      parser.tag.attributes[parser.attribName] = parser.attribValue\n      emitNode(parser, 'onattribute', {\n        name: parser.attribName,\n        value: parser.attribValue,\n      })\n    }\n\n    parser.attribName = parser.attribValue = ''\n  }\n\n  function openTag(parser, selfClosing) {\n    if (parser.opt.xmlns) {\n      // emit namespace binding events\n      var tag = parser.tag\n\n      // add namespace info to tag\n      var qn = qname(parser.tagName)\n      tag.prefix = qn.prefix\n      tag.local = qn.local\n      tag.uri = tag.ns[qn.prefix] || ''\n\n      if (tag.prefix && !tag.uri) {\n        strictFail(\n          parser,\n          'Unbound namespace prefix: ' + JSON.stringify(parser.tagName)\n        )\n        tag.uri = qn.prefix\n      }\n\n      var parent = parser.tags[parser.tags.length - 1] || parser\n      if (tag.ns && parent.ns !== tag.ns) {\n        Object.keys(tag.ns).forEach(function (p) {\n          emitNode(parser, 'onopennamespace', {\n            prefix: p,\n            uri: tag.ns[p],\n          })\n        })\n      }\n\n      // handle deferred onattribute events\n      // Note: do not apply default ns to attributes:\n      //   http://www.w3.org/TR/REC-xml-names/#defaulting\n      for (var i = 0, l = parser.attribList.length; i < l; i++) {\n        var nv = parser.attribList[i]\n        var name = nv[0]\n        var value = nv[1]\n        var qualName = qname(name, true)\n        var prefix = qualName.prefix\n        var local = qualName.local\n        var uri = prefix === '' ? '' : tag.ns[prefix] || ''\n        var a = {\n          name: name,\n          value: value,\n          prefix: prefix,\n          local: local,\n          uri: uri,\n        }\n\n        // if there's any attributes with an undefined namespace,\n        // then fail on them now.\n        if (prefix && prefix !== 'xmlns' && !uri) {\n          strictFail(\n            parser,\n            'Unbound namespace prefix: ' + JSON.stringify(prefix)\n          )\n          a.uri = prefix\n        }\n        parser.tag.attributes[name] = a\n        emitNode(parser, 'onattribute', a)\n      }\n      parser.attribList.length = 0\n    }\n\n    parser.tag.isSelfClosing = !!selfClosing\n\n    // process the tag\n    parser.sawRoot = true\n    parser.tags.push(parser.tag)\n    emitNode(parser, 'onopentag', parser.tag)\n    if (!selfClosing) {\n      // special case for <script> in non-strict mode.\n      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {\n        parser.state = S.SCRIPT\n      } else {\n        parser.state = S.TEXT\n      }\n      parser.tag = null\n      parser.tagName = ''\n    }\n    parser.attribName = parser.attribValue = ''\n    parser.attribList.length = 0\n  }\n\n  function closeTag(parser) {\n    if (!parser.tagName) {\n      strictFail(parser, 'Weird empty close tag.')\n      parser.textNode += '</>'\n      parser.state = S.TEXT\n      return\n    }\n\n    if (parser.script) {\n      if (parser.tagName !== 'script') {\n        parser.script += '</' + parser.tagName + '>'\n        parser.tagName = ''\n        parser.state = S.SCRIPT\n        return\n      }\n      emitNode(parser, 'onscript', parser.script)\n      parser.script = ''\n    }\n\n    // first make sure that the closing tag actually exists.\n    // <a><b></c></b></a> will close everything, otherwise.\n    var t = parser.tags.length\n    var tagName = parser.tagName\n    if (!parser.strict) {\n      tagName = tagName[parser.looseCase]()\n    }\n    var closeTo = tagName\n    while (t--) {\n      var close = parser.tags[t]\n      if (close.name !== closeTo) {\n        // fail the first time in strict mode\n        strictFail(parser, 'Unexpected close tag')\n      } else {\n        break\n      }\n    }\n\n    // didn't find it.  we already failed for strict, so just abort.\n    if (t < 0) {\n      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName)\n      parser.textNode += '</' + parser.tagName + '>'\n      parser.state = S.TEXT\n      return\n    }\n    parser.tagName = tagName\n    var s = parser.tags.length\n    while (s-- > t) {\n      var tag = (parser.tag = parser.tags.pop())\n      parser.tagName = parser.tag.name\n      emitNode(parser, 'onclosetag', parser.tagName)\n\n      var x = {}\n      for (var i in tag.ns) {\n        x[i] = tag.ns[i]\n      }\n\n      var parent = parser.tags[parser.tags.length - 1] || parser\n      if (parser.opt.xmlns && tag.ns !== parent.ns) {\n        // remove namespace bindings introduced by tag\n        Object.keys(tag.ns).forEach(function (p) {\n          var n = tag.ns[p]\n          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n })\n        })\n      }\n    }\n    if (t === 0) parser.closedRoot = true\n    parser.tagName = parser.attribValue = parser.attribName = ''\n    parser.attribList.length = 0\n    parser.state = S.TEXT\n  }\n\n  function parseEntity(parser) {\n    var entity = parser.entity\n    var entityLC = entity.toLowerCase()\n    var num\n    var numStr = ''\n\n    if (parser.ENTITIES[entity]) {\n      return parser.ENTITIES[entity]\n    }\n    if (parser.ENTITIES[entityLC]) {\n      return parser.ENTITIES[entityLC]\n    }\n    entity = entityLC\n    if (entity.charAt(0) === '#') {\n      if (entity.charAt(1) === 'x') {\n        entity = entity.slice(2)\n        num = parseInt(entity, 16)\n        numStr = num.toString(16)\n      } else {\n        entity = entity.slice(1)\n        num = parseInt(entity, 10)\n        numStr = num.toString(10)\n      }\n    }\n    entity = entity.replace(/^0+/, '')\n    if (\n      isNaN(num) ||\n      numStr.toLowerCase() !== entity ||\n      num < 0 ||\n      num > 0x10ffff\n    ) {\n      strictFail(parser, 'Invalid character entity')\n      return '&' + parser.entity + ';'\n    }\n\n    return String.fromCodePoint(num)\n  }\n\n  function beginWhiteSpace(parser, c) {\n    if (c === '<') {\n      parser.state = S.OPEN_WAKA\n      parser.startTagPosition = parser.position\n    } else if (!isWhitespace(c)) {\n      // have to process this as a text node.\n      // weird, but happens.\n      strictFail(parser, 'Non-whitespace before first tag.')\n      parser.textNode = c\n      parser.state = S.TEXT\n    }\n  }\n\n  function charAt(chunk, i) {\n    var result = ''\n    if (i < chunk.length) {\n      result = chunk.charAt(i)\n    }\n    return result\n  }\n\n  function write(chunk) {\n    var parser = this\n    if (this.error) {\n      throw this.error\n    }\n    if (parser.closed) {\n      return error(\n        parser,\n        'Cannot write after close. Assign an onready handler.'\n      )\n    }\n    if (chunk === null) {\n      return end(parser)\n    }\n    if (typeof chunk === 'object') {\n      chunk = chunk.toString()\n    }\n    var i = 0\n    var c = ''\n    while (true) {\n      c = charAt(chunk, i++)\n      parser.c = c\n\n      if (!c) {\n        break\n      }\n\n      if (parser.trackPosition) {\n        parser.position++\n        if (c === '\\n') {\n          parser.line++\n          parser.column = 0\n        } else {\n          parser.column++\n        }\n      }\n\n      switch (parser.state) {\n        case S.BEGIN:\n          parser.state = S.BEGIN_WHITESPACE\n          if (c === '\\uFEFF') {\n            continue\n          }\n          beginWhiteSpace(parser, c)\n          continue\n\n        case S.BEGIN_WHITESPACE:\n          beginWhiteSpace(parser, c)\n          continue\n\n        case S.TEXT:\n          if (parser.sawRoot && !parser.closedRoot) {\n            var starti = i - 1\n            while (c && c !== '<' && c !== '&') {\n              c = charAt(chunk, i++)\n              if (c && parser.trackPosition) {\n                parser.position++\n                if (c === '\\n') {\n                  parser.line++\n                  parser.column = 0\n                } else {\n                  parser.column++\n                }\n              }\n            }\n            parser.textNode += chunk.substring(starti, i - 1)\n          }\n          if (\n            c === '<' &&\n            !(parser.sawRoot && parser.closedRoot && !parser.strict)\n          ) {\n            parser.state = S.OPEN_WAKA\n            parser.startTagPosition = parser.position\n          } else {\n            if (\n              !isWhitespace(c) &&\n              (!parser.sawRoot || parser.closedRoot)\n            ) {\n              strictFail(parser, 'Text data outside of root node.')\n            }\n            if (c === '&') {\n              parser.state = S.TEXT_ENTITY\n            } else {\n              parser.textNode += c\n            }\n          }\n          continue\n\n        case S.SCRIPT:\n          // only non-strict\n          if (c === '<') {\n            parser.state = S.SCRIPT_ENDING\n          } else {\n            parser.script += c\n          }\n          continue\n\n        case S.SCRIPT_ENDING:\n          if (c === '/') {\n            parser.state = S.CLOSE_TAG\n          } else {\n            parser.script += '<' + c\n            parser.state = S.SCRIPT\n          }\n          continue\n\n        case S.OPEN_WAKA:\n          // either a /, ?, !, or text is coming next.\n          if (c === '!') {\n            parser.state = S.SGML_DECL\n            parser.sgmlDecl = ''\n          } else if (isWhitespace(c)) {\n            // wait for it...\n          } else if (isMatch(nameStart, c)) {\n            parser.state = S.OPEN_TAG\n            parser.tagName = c\n          } else if (c === '/') {\n            parser.state = S.CLOSE_TAG\n            parser.tagName = ''\n          } else if (c === '?') {\n            parser.state = S.PROC_INST\n            parser.procInstName = parser.procInstBody = ''\n          } else {\n            strictFail(parser, 'Unencoded <')\n            // if there was some whitespace, then add that in.\n            if (parser.startTagPosition + 1 < parser.position) {\n              var pad = parser.position - parser.startTagPosition\n              c = new Array(pad).join(' ') + c\n            }\n            parser.textNode += '<' + c\n            parser.state = S.TEXT\n          }\n          continue\n\n        case S.SGML_DECL:\n          if (parser.sgmlDecl + c === '--') {\n            parser.state = S.COMMENT\n            parser.comment = ''\n            parser.sgmlDecl = ''\n            continue\n          }\n\n          if (\n            parser.doctype &&\n            parser.doctype !== true &&\n            parser.sgmlDecl\n          ) {\n            parser.state = S.DOCTYPE_DTD\n            parser.doctype += '<!' + parser.sgmlDecl + c\n            parser.sgmlDecl = ''\n          } else if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {\n            emitNode(parser, 'onopencdata')\n            parser.state = S.CDATA\n            parser.sgmlDecl = ''\n            parser.cdata = ''\n          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {\n            parser.state = S.DOCTYPE\n            if (parser.doctype || parser.sawRoot) {\n              strictFail(\n                parser,\n                'Inappropriately located doctype declaration'\n              )\n            }\n            parser.doctype = ''\n            parser.sgmlDecl = ''\n          } else if (c === '>') {\n            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl)\n            parser.sgmlDecl = ''\n            parser.state = S.TEXT\n          } else if (isQuote(c)) {\n            parser.state = S.SGML_DECL_QUOTED\n            parser.sgmlDecl += c\n          } else {\n            parser.sgmlDecl += c\n          }\n          continue\n\n        case S.SGML_DECL_QUOTED:\n          if (c === parser.q) {\n            parser.state = S.SGML_DECL\n            parser.q = ''\n          }\n          parser.sgmlDecl += c\n          continue\n\n        case S.DOCTYPE:\n          if (c === '>') {\n            parser.state = S.TEXT\n            emitNode(parser, 'ondoctype', parser.doctype)\n            parser.doctype = true // just remember that we saw it.\n          } else {\n            parser.doctype += c\n            if (c === '[') {\n              parser.state = S.DOCTYPE_DTD\n            } else if (isQuote(c)) {\n              parser.state = S.DOCTYPE_QUOTED\n              parser.q = c\n            }\n          }\n          continue\n\n        case S.DOCTYPE_QUOTED:\n          parser.doctype += c\n          if (c === parser.q) {\n            parser.q = ''\n            parser.state = S.DOCTYPE\n          }\n          continue\n\n        case S.DOCTYPE_DTD:\n          if (c === ']') {\n            parser.doctype += c\n            parser.state = S.DOCTYPE\n          } else if (c === '<') {\n            parser.state = S.OPEN_WAKA\n            parser.startTagPosition = parser.position\n          } else if (isQuote(c)) {\n            parser.doctype += c\n            parser.state = S.DOCTYPE_DTD_QUOTED\n            parser.q = c\n          } else {\n            parser.doctype += c\n          }\n          continue\n\n        case S.DOCTYPE_DTD_QUOTED:\n          parser.doctype += c\n          if (c === parser.q) {\n            parser.state = S.DOCTYPE_DTD\n            parser.q = ''\n          }\n          continue\n\n        case S.COMMENT:\n          if (c === '-') {\n            parser.state = S.COMMENT_ENDING\n          } else {\n            parser.comment += c\n          }\n          continue\n\n        case S.COMMENT_ENDING:\n          if (c === '-') {\n            parser.state = S.COMMENT_ENDED\n            parser.comment = textopts(parser.opt, parser.comment)\n            if (parser.comment) {\n              emitNode(parser, 'oncomment', parser.comment)\n            }\n            parser.comment = ''\n          } else {\n            parser.comment += '-' + c\n            parser.state = S.COMMENT\n          }\n          continue\n\n        case S.COMMENT_ENDED:\n          if (c !== '>') {\n            strictFail(parser, 'Malformed comment')\n            // allow <!-- blah -- bloo --> in non-strict mode,\n            // which is a comment of \" blah -- bloo \"\n            parser.comment += '--' + c\n            parser.state = S.COMMENT\n          } else if (parser.doctype && parser.doctype !== true) {\n            parser.state = S.DOCTYPE_DTD\n          } else {\n            parser.state = S.TEXT\n          }\n          continue\n\n        case S.CDATA:\n          var starti = i - 1\n          while (c && c !== ']') {\n            c = charAt(chunk, i++)\n            if (c && parser.trackPosition) {\n              parser.position++\n              if (c === '\\n') {\n                parser.line++\n                parser.column = 0\n              } else {\n                parser.column++\n              }\n            }\n          }\n          parser.cdata += chunk.substring(starti, i - 1)\n          if (c === ']') {\n            parser.state = S.CDATA_ENDING\n          }\n          continue\n\n        case S.CDATA_ENDING:\n          if (c === ']') {\n            parser.state = S.CDATA_ENDING_2\n          } else {\n            parser.cdata += ']' + c\n            parser.state = S.CDATA\n          }\n          continue\n\n        case S.CDATA_ENDING_2:\n          if (c === '>') {\n            if (parser.cdata) {\n              emitNode(parser, 'oncdata', parser.cdata)\n            }\n            emitNode(parser, 'onclosecdata')\n            parser.cdata = ''\n            parser.state = S.TEXT\n          } else if (c === ']') {\n            parser.cdata += ']'\n          } else {\n            parser.cdata += ']]' + c\n            parser.state = S.CDATA\n          }\n          continue\n\n        case S.PROC_INST:\n          if (c === '?') {\n            parser.state = S.PROC_INST_ENDING\n          } else if (isWhitespace(c)) {\n            parser.state = S.PROC_INST_BODY\n          } else {\n            parser.procInstName += c\n          }\n          continue\n\n        case S.PROC_INST_BODY:\n          if (!parser.procInstBody && isWhitespace(c)) {\n            continue\n          } else if (c === '?') {\n            parser.state = S.PROC_INST_ENDING\n          } else {\n            parser.procInstBody += c\n          }\n          continue\n\n        case S.PROC_INST_ENDING:\n          if (c === '>') {\n            emitNode(parser, 'onprocessinginstruction', {\n              name: parser.procInstName,\n              body: parser.procInstBody,\n            })\n            parser.procInstName = parser.procInstBody = ''\n            parser.state = S.TEXT\n          } else {\n            parser.procInstBody += '?' + c\n            parser.state = S.PROC_INST_BODY\n          }\n          continue\n\n        case S.OPEN_TAG:\n          if (isMatch(nameBody, c)) {\n            parser.tagName += c\n          } else {\n            newTag(parser)\n            if (c === '>') {\n              openTag(parser)\n            } else if (c === '/') {\n              parser.state = S.OPEN_TAG_SLASH\n            } else {\n              if (!isWhitespace(c)) {\n                strictFail(parser, 'Invalid character in tag name')\n              }\n              parser.state = S.ATTRIB\n            }\n          }\n          continue\n\n        case S.OPEN_TAG_SLASH:\n          if (c === '>') {\n            openTag(parser, true)\n            closeTag(parser)\n          } else {\n            strictFail(\n              parser,\n              'Forward-slash in opening tag not followed by >'\n            )\n            parser.state = S.ATTRIB\n          }\n          continue\n\n        case S.ATTRIB:\n          // haven't read the attribute name yet.\n          if (isWhitespace(c)) {\n            continue\n          } else if (c === '>') {\n            openTag(parser)\n          } else if (c === '/') {\n            parser.state = S.OPEN_TAG_SLASH\n          } else if (isMatch(nameStart, c)) {\n            parser.attribName = c\n            parser.attribValue = ''\n            parser.state = S.ATTRIB_NAME\n          } else {\n            strictFail(parser, 'Invalid attribute name')\n          }\n          continue\n\n        case S.ATTRIB_NAME:\n          if (c === '=') {\n            parser.state = S.ATTRIB_VALUE\n          } else if (c === '>') {\n            strictFail(parser, 'Attribute without value')\n            parser.attribValue = parser.attribName\n            attrib(parser)\n            openTag(parser)\n          } else if (isWhitespace(c)) {\n            parser.state = S.ATTRIB_NAME_SAW_WHITE\n          } else if (isMatch(nameBody, c)) {\n            parser.attribName += c\n          } else {\n            strictFail(parser, 'Invalid attribute name')\n          }\n          continue\n\n        case S.ATTRIB_NAME_SAW_WHITE:\n          if (c === '=') {\n            parser.state = S.ATTRIB_VALUE\n          } else if (isWhitespace(c)) {\n            continue\n          } else {\n            strictFail(parser, 'Attribute without value')\n            parser.tag.attributes[parser.attribName] = ''\n            parser.attribValue = ''\n            emitNode(parser, 'onattribute', {\n              name: parser.attribName,\n              value: '',\n            })\n            parser.attribName = ''\n            if (c === '>') {\n              openTag(parser)\n            } else if (isMatch(nameStart, c)) {\n              parser.attribName = c\n              parser.state = S.ATTRIB_NAME\n            } else {\n              strictFail(parser, 'Invalid attribute name')\n              parser.state = S.ATTRIB\n            }\n          }\n          continue\n\n        case S.ATTRIB_VALUE:\n          if (isWhitespace(c)) {\n            continue\n          } else if (isQuote(c)) {\n            parser.q = c\n            parser.state = S.ATTRIB_VALUE_QUOTED\n          } else {\n            if (!parser.opt.unquotedAttributeValues) {\n              error(parser, 'Unquoted attribute value')\n            }\n            parser.state = S.ATTRIB_VALUE_UNQUOTED\n            parser.attribValue = c\n          }\n          continue\n\n        case S.ATTRIB_VALUE_QUOTED:\n          if (c !== parser.q) {\n            if (c === '&') {\n              parser.state = S.ATTRIB_VALUE_ENTITY_Q\n            } else {\n              parser.attribValue += c\n            }\n            continue\n          }\n          attrib(parser)\n          parser.q = ''\n          parser.state = S.ATTRIB_VALUE_CLOSED\n          continue\n\n        case S.ATTRIB_VALUE_CLOSED:\n          if (isWhitespace(c)) {\n            parser.state = S.ATTRIB\n          } else if (c === '>') {\n            openTag(parser)\n          } else if (c === '/') {\n            parser.state = S.OPEN_TAG_SLASH\n          } else if (isMatch(nameStart, c)) {\n            strictFail(parser, 'No whitespace between attributes')\n            parser.attribName = c\n            parser.attribValue = ''\n            parser.state = S.ATTRIB_NAME\n          } else {\n            strictFail(parser, 'Invalid attribute name')\n          }\n          continue\n\n        case S.ATTRIB_VALUE_UNQUOTED:\n          if (!isAttribEnd(c)) {\n            if (c === '&') {\n              parser.state = S.ATTRIB_VALUE_ENTITY_U\n            } else {\n              parser.attribValue += c\n            }\n            continue\n          }\n          attrib(parser)\n          if (c === '>') {\n            openTag(parser)\n          } else {\n            parser.state = S.ATTRIB\n          }\n          continue\n\n        case S.CLOSE_TAG:\n          if (!parser.tagName) {\n            if (isWhitespace(c)) {\n              continue\n            } else if (notMatch(nameStart, c)) {\n              if (parser.script) {\n                parser.script += '</' + c\n                parser.state = S.SCRIPT\n              } else {\n                strictFail(parser, 'Invalid tagname in closing tag.')\n              }\n            } else {\n              parser.tagName = c\n            }\n          } else if (c === '>') {\n            closeTag(parser)\n          } else if (isMatch(nameBody, c)) {\n            parser.tagName += c\n          } else if (parser.script) {\n            parser.script += '</' + parser.tagName + c\n            parser.tagName = ''\n            parser.state = S.SCRIPT\n          } else {\n            if (!isWhitespace(c)) {\n              strictFail(parser, 'Invalid tagname in closing tag')\n            }\n            parser.state = S.CLOSE_TAG_SAW_WHITE\n          }\n          continue\n\n        case S.CLOSE_TAG_SAW_WHITE:\n          if (isWhitespace(c)) {\n            continue\n          }\n          if (c === '>') {\n            closeTag(parser)\n          } else {\n            strictFail(parser, 'Invalid characters in closing tag')\n          }\n          continue\n\n        case S.TEXT_ENTITY:\n        case S.ATTRIB_VALUE_ENTITY_Q:\n        case S.ATTRIB_VALUE_ENTITY_U:\n          var returnState\n          var buffer\n          switch (parser.state) {\n            case S.TEXT_ENTITY:\n              returnState = S.TEXT\n              buffer = 'textNode'\n              break\n\n            case S.ATTRIB_VALUE_ENTITY_Q:\n              returnState = S.ATTRIB_VALUE_QUOTED\n              buffer = 'attribValue'\n              break\n\n            case S.ATTRIB_VALUE_ENTITY_U:\n              returnState = S.ATTRIB_VALUE_UNQUOTED\n              buffer = 'attribValue'\n              break\n          }\n\n          if (c === ';') {\n            var parsedEntity = parseEntity(parser)\n            if (\n              parser.opt.unparsedEntities &&\n              !Object.values(sax.XML_ENTITIES).includes(parsedEntity)\n            ) {\n              parser.entity = ''\n              parser.state = returnState\n              parser.write(parsedEntity)\n            } else {\n              parser[buffer] += parsedEntity\n              parser.entity = ''\n              parser.state = returnState\n            }\n          } else if (\n            isMatch(parser.entity.length ? entityBody : entityStart, c)\n          ) {\n            parser.entity += c\n          } else {\n            strictFail(parser, 'Invalid character in entity name')\n            parser[buffer] += '&' + parser.entity + c\n            parser.entity = ''\n            parser.state = returnState\n          }\n\n          continue\n\n        default: /* istanbul ignore next */ {\n          throw new Error(parser, 'Unknown state: ' + parser.state)\n        }\n      }\n    } // while\n\n    if (parser.position >= parser.bufferCheckPosition) {\n      checkBufferLength(parser)\n    }\n    return parser\n  }\n\n  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */\n  /* istanbul ignore next */\n  if (!String.fromCodePoint) {\n    ;(function () {\n      var stringFromCharCode = String.fromCharCode\n      var floor = Math.floor\n      var fromCodePoint = function () {\n        var MAX_SIZE = 0x4000\n        var codeUnits = []\n        var highSurrogate\n        var lowSurrogate\n        var index = -1\n        var length = arguments.length\n        if (!length) {\n          return ''\n        }\n        var result = ''\n        while (++index < length) {\n          var codePoint = Number(arguments[index])\n          if (\n            !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n            codePoint < 0 || // not a valid Unicode code point\n            codePoint > 0x10ffff || // not a valid Unicode code point\n            floor(codePoint) !== codePoint // not an integer\n          ) {\n            throw RangeError('Invalid code point: ' + codePoint)\n          }\n          if (codePoint <= 0xffff) {\n            // BMP code point\n            codeUnits.push(codePoint)\n          } else {\n            // Astral code point; split in surrogate halves\n            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n            codePoint -= 0x10000\n            highSurrogate = (codePoint >> 10) + 0xd800\n            lowSurrogate = (codePoint % 0x400) + 0xdc00\n            codeUnits.push(highSurrogate, lowSurrogate)\n          }\n          if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n            result += stringFromCharCode.apply(null, codeUnits)\n            codeUnits.length = 0\n          }\n        }\n        return result\n      }\n      /* istanbul ignore next */\n      if (Object.defineProperty) {\n        Object.defineProperty(String, 'fromCodePoint', {\n          value: fromCodePoint,\n          configurable: true,\n          writable: true,\n        })\n      } else {\n        String.fromCodePoint = fromCodePoint\n      }\n    })()\n  }\n})(typeof exports === 'undefined' ? (this.sax = {}) : exports)\n","// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n","// DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n// https://tools.ietf.org/html/rfc1951\n// You may also wish to take a look at the guide I made about this program:\n// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad\n// Some of the following code is similar to that of UZIP.js:\n// https://github.com/photopea/UZIP.js\n// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.\n// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint\n// is better for memory in most engines (I *think*).\nvar ch2 = {};\nvar wk = (function (c, id, msg, transfer, cb) {\n    var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([\n        c + ';addEventListener(\"error\",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'\n    ], { type: 'text/javascript' }))));\n    w.onmessage = function (e) {\n        var d = e.data, ed = d.$e$;\n        if (ed) {\n            var err = new Error(ed[0]);\n            err['code'] = ed[1];\n            err.stack = ed[2];\n            cb(err, null);\n        }\n        else\n            cb(null, d);\n    };\n    w.postMessage(msg, transfer);\n    return w;\n});\n\n// aliases for shorter compressed code (most minifers don't do this)\nvar u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;\n// fixed length extra bits\nvar fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);\n// fixed distance extra bits\nvar fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);\n// code length index map\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n// get base, reverse index map from extra bits\nvar freb = function (eb, start) {\n    var b = new u16(31);\n    for (var i = 0; i < 31; ++i) {\n        b[i] = start += 1 << eb[i - 1];\n    }\n    // numbers here are at max 18 bits\n    var r = new i32(b[30]);\n    for (var i = 1; i < 30; ++i) {\n        for (var j = b[i]; j < b[i + 1]; ++j) {\n            r[j] = ((j - b[i]) << 5) | i;\n        }\n    }\n    return { b: b, r: r };\n};\nvar _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = _b.b, revfd = _b.r;\n// map of value to reverse (assuming 16 bits)\nvar rev = new u16(32768);\nfor (var i = 0; i < 32768; ++i) {\n    // reverse table algorithm from SO\n    var x = ((i & 0xAAAA) >> 1) | ((i & 0x5555) << 1);\n    x = ((x & 0xCCCC) >> 2) | ((x & 0x3333) << 2);\n    x = ((x & 0xF0F0) >> 4) | ((x & 0x0F0F) << 4);\n    rev[i] = (((x & 0xFF00) >> 8) | ((x & 0x00FF) << 8)) >> 1;\n}\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nvar hMap = (function (cd, mb, r) {\n    var s = cd.length;\n    // index\n    var i = 0;\n    // u16 \"map\": index -> # of codes with bit length = index\n    var l = new u16(mb);\n    // length of cd must be 288 (total # of codes)\n    for (; i < s; ++i) {\n        if (cd[i])\n            ++l[cd[i] - 1];\n    }\n    // u16 \"map\": index -> minimum code for bit length = index\n    var le = new u16(mb);\n    for (i = 1; i < mb; ++i) {\n        le[i] = (le[i - 1] + l[i - 1]) << 1;\n    }\n    var co;\n    if (r) {\n        // u16 \"map\": index -> number of actual bits, symbol for code\n        co = new u16(1 << mb);\n        // bits to remove for reverser\n        var rvb = 15 - mb;\n        for (i = 0; i < s; ++i) {\n            // ignore 0 lengths\n            if (cd[i]) {\n                // num encoding both symbol and bits read\n                var sv = (i << 4) | cd[i];\n                // free bits\n                var r_1 = mb - cd[i];\n                // start value\n                var v = le[cd[i] - 1]++ << r_1;\n                // m is end value\n                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {\n                    // every 16 bit value starting with the code yields the same result\n                    co[rev[v] >> rvb] = sv;\n                }\n            }\n        }\n    }\n    else {\n        co = new u16(s);\n        for (i = 0; i < s; ++i) {\n            if (cd[i]) {\n                co[i] = rev[le[cd[i] - 1]++] >> (15 - cd[i]);\n            }\n        }\n    }\n    return co;\n});\n// fixed length tree\nvar flt = new u8(288);\nfor (var i = 0; i < 144; ++i)\n    flt[i] = 8;\nfor (var i = 144; i < 256; ++i)\n    flt[i] = 9;\nfor (var i = 256; i < 280; ++i)\n    flt[i] = 7;\nfor (var i = 280; i < 288; ++i)\n    flt[i] = 8;\n// fixed distance tree\nvar fdt = new u8(32);\nfor (var i = 0; i < 32; ++i)\n    fdt[i] = 5;\n// fixed length map\nvar flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);\n// fixed distance map\nvar fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);\n// find max of array\nvar max = function (a) {\n    var m = a[0];\n    for (var i = 1; i < a.length; ++i) {\n        if (a[i] > m)\n            m = a[i];\n    }\n    return m;\n};\n// read d, starting at bit p and mask with m\nvar bits = function (d, p, m) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;\n};\n// read d, starting at bit p continuing for at least 16 bits\nvar bits16 = function (d, p) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));\n};\n// get end of byte\nvar shft = function (p) { return ((p + 7) / 8) | 0; };\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nvar slc = function (v, s, e) {\n    if (s == null || s < 0)\n        s = 0;\n    if (e == null || e > v.length)\n        e = v.length;\n    // can't use .constructor in case user-supplied\n    return new u8(v.subarray(s, e));\n};\n/**\n * Codes for errors generated within this library\n */\nexport var FlateErrorCode = {\n    UnexpectedEOF: 0,\n    InvalidBlockType: 1,\n    InvalidLengthLiteral: 2,\n    InvalidDistance: 3,\n    StreamFinished: 4,\n    NoStreamHandler: 5,\n    InvalidHeader: 6,\n    NoCallback: 7,\n    InvalidUTF8: 8,\n    ExtraFieldTooLong: 9,\n    InvalidDate: 10,\n    FilenameTooLong: 11,\n    StreamFinishing: 12,\n    InvalidZipData: 13,\n    UnknownCompressionMethod: 14\n};\n// error codes\nvar ec = [\n    'unexpected EOF',\n    'invalid block type',\n    'invalid length/literal',\n    'invalid distance',\n    'stream finished',\n    'no stream handler',\n    ,\n    'no callback',\n    'invalid UTF-8 data',\n    'extra field too long',\n    'date not in range 1980-2099',\n    'filename too long',\n    'stream finishing',\n    'invalid zip data'\n    // determined by unknown compression method\n];\n;\nvar err = function (ind, msg, nt) {\n    var e = new Error(msg || ec[ind]);\n    e.code = ind;\n    if (Error.captureStackTrace)\n        Error.captureStackTrace(e, err);\n    if (!nt)\n        throw e;\n    return e;\n};\n// expands raw DEFLATE data\nvar inflt = function (dat, st, buf, dict) {\n    // source length       dict length\n    var sl = dat.length, dl = dict ? dict.length : 0;\n    if (!sl || st.f && !st.l)\n        return buf || new u8(0);\n    var noBuf = !buf;\n    // have to estimate size\n    var resize = noBuf || st.i != 2;\n    // no state\n    var noSt = st.i;\n    // Assumes roughly 33% compression ratio average\n    if (noBuf)\n        buf = new u8(sl * 3);\n    // ensure buffer can fit at least l elements\n    var cbuf = function (l) {\n        var bl = buf.length;\n        // need to increase size to fit\n        if (l > bl) {\n            // Double or set to necessary, whichever is greater\n            var nbuf = new u8(Math.max(bl * 2, l));\n            nbuf.set(buf);\n            buf = nbuf;\n        }\n    };\n    //  last chunk         bitpos           bytes\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    // total bits\n    var tbts = sl * 8;\n    do {\n        if (!lm) {\n            // BFINAL - this is only 1 when last chunk is next\n            final = bits(dat, pos, 1);\n            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n            var type = bits(dat, pos + 1, 3);\n            pos += 3;\n            if (!type) {\n                // go to end of byte boundary\n                var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;\n                if (t > sl) {\n                    if (noSt)\n                        err(0);\n                    break;\n                }\n                // ensure size\n                if (resize)\n                    cbuf(bt + l);\n                // Copy over uncompressed data\n                buf.set(dat.subarray(s, t), bt);\n                // Get new bitpos, update byte count\n                st.b = bt += l, st.p = pos = t * 8, st.f = final;\n                continue;\n            }\n            else if (type == 1)\n                lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n            else if (type == 2) {\n                //  literal                            lengths\n                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n                var tl = hLit + bits(dat, pos + 5, 31) + 1;\n                pos += 14;\n                // length+distance tree\n                var ldt = new u8(tl);\n                // code length tree\n                var clt = new u8(19);\n                for (var i = 0; i < hcLen; ++i) {\n                    // use index map to get real code\n                    clt[clim[i]] = bits(dat, pos + i * 3, 7);\n                }\n                pos += hcLen * 3;\n                // code lengths bits\n                var clb = max(clt), clbmsk = (1 << clb) - 1;\n                // code lengths map\n                var clm = hMap(clt, clb, 1);\n                for (var i = 0; i < tl;) {\n                    var r = clm[bits(dat, pos, clbmsk)];\n                    // bits read\n                    pos += r & 15;\n                    // symbol\n                    var s = r >> 4;\n                    // code length to copy\n                    if (s < 16) {\n                        ldt[i++] = s;\n                    }\n                    else {\n                        //  copy   count\n                        var c = 0, n = 0;\n                        if (s == 16)\n                            n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n                        else if (s == 17)\n                            n = 3 + bits(dat, pos, 7), pos += 3;\n                        else if (s == 18)\n                            n = 11 + bits(dat, pos, 127), pos += 7;\n                        while (n--)\n                            ldt[i++] = c;\n                    }\n                }\n                //    length tree                 distance tree\n                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n                // max length bits\n                lbt = max(lt);\n                // max dist bits\n                dbt = max(dt);\n                lm = hMap(lt, lbt, 1);\n                dm = hMap(dt, dbt, 1);\n            }\n            else\n                err(1);\n            if (pos > tbts) {\n                if (noSt)\n                    err(0);\n                break;\n            }\n        }\n        // Make sure the buffer can hold this + the largest possible addition\n        // Maximum chunk size (practically, theoretically infinite) is 2^17\n        if (resize)\n            cbuf(bt + 131072);\n        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n        var lpos = pos;\n        for (;; lpos = pos) {\n            // bits read, code\n            var c = lm[bits16(dat, pos) & lms], sym = c >> 4;\n            pos += c & 15;\n            if (pos > tbts) {\n                if (noSt)\n                    err(0);\n                break;\n            }\n            if (!c)\n                err(2);\n            if (sym < 256)\n                buf[bt++] = sym;\n            else if (sym == 256) {\n                lpos = pos, lm = null;\n                break;\n            }\n            else {\n                var add = sym - 254;\n                // no extra bits needed if less\n                if (sym > 264) {\n                    // index\n                    var i = sym - 257, b = fleb[i];\n                    add = bits(dat, pos, (1 << b) - 1) + fl[i];\n                    pos += b;\n                }\n                // dist\n                var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;\n                if (!d)\n                    err(3);\n                pos += d & 15;\n                var dt = fd[dsym];\n                if (dsym > 3) {\n                    var b = fdeb[dsym];\n                    dt += bits16(dat, pos) & (1 << b) - 1, pos += b;\n                }\n                if (pos > tbts) {\n                    if (noSt)\n                        err(0);\n                    break;\n                }\n                if (resize)\n                    cbuf(bt + 131072);\n                var end = bt + add;\n                if (bt < dt) {\n                    var shift = dl - dt, dend = Math.min(dt, end);\n                    if (shift + bt < 0)\n                        err(3);\n                    for (; bt < dend; ++bt)\n                        buf[bt] = dict[shift + bt];\n                }\n                for (; bt < end; ++bt)\n                    buf[bt] = buf[bt - dt];\n            }\n        }\n        st.l = lm, st.p = lpos, st.b = bt, st.f = final;\n        if (lm)\n            final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    } while (!final);\n    // don't reallocate for streams or user buffers\n    return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);\n};\n// starting at p, write the minimum number of bits that can hold v to d\nvar wbits = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >> 8;\n};\n// starting at p, write the minimum number of bits (>8) that can hold v to d\nvar wbits16 = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >> 8;\n    d[o + 2] |= v >> 16;\n};\n// creates code lengths from a frequency table\nvar hTree = function (d, mb) {\n    // Need extra info to make a tree\n    var t = [];\n    for (var i = 0; i < d.length; ++i) {\n        if (d[i])\n            t.push({ s: i, f: d[i] });\n    }\n    var s = t.length;\n    var t2 = t.slice();\n    if (!s)\n        return { t: et, l: 0 };\n    if (s == 1) {\n        var v = new u8(t[0].s + 1);\n        v[t[0].s] = 1;\n        return { t: v, l: 1 };\n    }\n    t.sort(function (a, b) { return a.f - b.f; });\n    // after i2 reaches last ind, will be stopped\n    // freq must be greater than largest possible number of symbols\n    t.push({ s: -1, f: 25001 });\n    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;\n    t[0] = { s: -1, f: l.f + r.f, l: l, r: r };\n    // efficient algorithm from UZIP.js\n    // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n    // symbols that combined have high freq, will start processing i2 (high-freq,\n    // non-composite) symbols instead\n    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n    while (i1 != s - 1) {\n        l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n        t[i1++] = { s: -1, f: l.f + r.f, l: l, r: r };\n    }\n    var maxSym = t2[0].s;\n    for (var i = 1; i < s; ++i) {\n        if (t2[i].s > maxSym)\n            maxSym = t2[i].s;\n    }\n    // code lengths\n    var tr = new u16(maxSym + 1);\n    // max bits in tree\n    var mbt = ln(t[i1 - 1], tr, 0);\n    if (mbt > mb) {\n        // more algorithms from UZIP.js\n        // TODO: find out how this code works (debt)\n        //  ind    debt\n        var i = 0, dt = 0;\n        //    left            cost\n        var lft = mbt - mb, cst = 1 << lft;\n        t2.sort(function (a, b) { return tr[b.s] - tr[a.s] || a.f - b.f; });\n        for (; i < s; ++i) {\n            var i2_1 = t2[i].s;\n            if (tr[i2_1] > mb) {\n                dt += cst - (1 << (mbt - tr[i2_1]));\n                tr[i2_1] = mb;\n            }\n            else\n                break;\n        }\n        dt >>= lft;\n        while (dt > 0) {\n            var i2_2 = t2[i].s;\n            if (tr[i2_2] < mb)\n                dt -= 1 << (mb - tr[i2_2]++ - 1);\n            else\n                ++i;\n        }\n        for (; i >= 0 && dt; --i) {\n            var i2_3 = t2[i].s;\n            if (tr[i2_3] == mb) {\n                --tr[i2_3];\n                ++dt;\n            }\n        }\n        mbt = mb;\n    }\n    return { t: new u8(tr), l: mbt };\n};\n// get the max length and assign length codes\nvar ln = function (n, l, d) {\n    return n.s == -1\n        ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))\n        : (l[n.s] = d);\n};\n// length codes generation\nvar lc = function (c) {\n    var s = c.length;\n    // Note that the semicolon was intentional\n    while (s && !c[--s])\n        ;\n    var cl = new u16(++s);\n    //  ind      num         streak\n    var cli = 0, cln = c[0], cls = 1;\n    var w = function (v) { cl[cli++] = v; };\n    for (var i = 1; i <= s; ++i) {\n        if (c[i] == cln && i != s)\n            ++cls;\n        else {\n            if (!cln && cls > 2) {\n                for (; cls > 138; cls -= 138)\n                    w(32754);\n                if (cls > 2) {\n                    w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305);\n                    cls = 0;\n                }\n            }\n            else if (cls > 3) {\n                w(cln), --cls;\n                for (; cls > 6; cls -= 6)\n                    w(8304);\n                if (cls > 2)\n                    w(((cls - 3) << 5) | 8208), cls = 0;\n            }\n            while (cls--)\n                w(cln);\n            cls = 1;\n            cln = c[i];\n        }\n    }\n    return { c: cl.subarray(0, cli), n: s };\n};\n// calculate the length of output from tree, code lengths\nvar clen = function (cf, cl) {\n    var l = 0;\n    for (var i = 0; i < cl.length; ++i)\n        l += cf[i] * cl[i];\n    return l;\n};\n// writes a fixed block\n// returns the new bit pos\nvar wfblk = function (out, pos, dat) {\n    // no need to write 00 as type: TypedArray defaults to 0\n    var s = dat.length;\n    var o = shft(pos + 2);\n    out[o] = s & 255;\n    out[o + 1] = s >> 8;\n    out[o + 2] = out[o] ^ 255;\n    out[o + 3] = out[o + 1] ^ 255;\n    for (var i = 0; i < s; ++i)\n        out[o + i + 4] = dat[i];\n    return (o + 4 + s) * 8;\n};\n// writes a block\nvar wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\n    wbits(out, p++, final);\n    ++lf[256];\n    var _a = hTree(lf, 15), dlt = _a.t, mlb = _a.l;\n    var _b = hTree(df, 15), ddt = _b.t, mdb = _b.l;\n    var _c = lc(dlt), lclt = _c.c, nlc = _c.n;\n    var _d = lc(ddt), lcdt = _d.c, ndc = _d.n;\n    var lcfreq = new u16(19);\n    for (var i = 0; i < lclt.length; ++i)\n        ++lcfreq[lclt[i] & 31];\n    for (var i = 0; i < lcdt.length; ++i)\n        ++lcfreq[lcdt[i] & 31];\n    var _e = hTree(lcfreq, 7), lct = _e.t, mlcb = _e.l;\n    var nlcc = 19;\n    for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)\n        ;\n    var flen = (bl + 5) << 3;\n    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];\n    if (bs >= 0 && flen <= ftlen && flen <= dtlen)\n        return wfblk(out, p, dat.subarray(bs, bs + bl));\n    var lm, ll, dm, dl;\n    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;\n    if (dtlen < ftlen) {\n        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n        var llm = hMap(lct, mlcb, 0);\n        wbits(out, p, nlc - 257);\n        wbits(out, p + 5, ndc - 1);\n        wbits(out, p + 10, nlcc - 4);\n        p += 14;\n        for (var i = 0; i < nlcc; ++i)\n            wbits(out, p + 3 * i, lct[clim[i]]);\n        p += 3 * nlcc;\n        var lcts = [lclt, lcdt];\n        for (var it = 0; it < 2; ++it) {\n            var clct = lcts[it];\n            for (var i = 0; i < clct.length; ++i) {\n                var len = clct[i] & 31;\n                wbits(out, p, llm[len]), p += lct[len];\n                if (len > 15)\n                    wbits(out, p, (clct[i] >> 5) & 127), p += clct[i] >> 12;\n            }\n        }\n    }\n    else {\n        lm = flm, ll = flt, dm = fdm, dl = fdt;\n    }\n    for (var i = 0; i < li; ++i) {\n        var sym = syms[i];\n        if (sym > 255) {\n            var len = (sym >> 18) & 31;\n            wbits16(out, p, lm[len + 257]), p += ll[len + 257];\n            if (len > 7)\n                wbits(out, p, (sym >> 23) & 31), p += fleb[len];\n            var dst = sym & 31;\n            wbits16(out, p, dm[dst]), p += dl[dst];\n            if (dst > 3)\n                wbits16(out, p, (sym >> 5) & 8191), p += fdeb[dst];\n        }\n        else {\n            wbits16(out, p, lm[sym]), p += ll[sym];\n        }\n    }\n    wbits16(out, p, lm[256]);\n    return p + ll[256];\n};\n// deflate options (nice << 13) | chain\nvar deo = /*#__PURE__*/ new i32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);\n// empty\nvar et = /*#__PURE__*/ new u8(0);\n// compresses data into a raw DEFLATE buffer\nvar dflt = function (dat, lvl, plvl, pre, post, st) {\n    var s = st.z || dat.length;\n    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);\n    // writing to this writes to the output buffer\n    var w = o.subarray(pre, o.length - post);\n    var lst = st.l;\n    var pos = (st.r || 0) & 7;\n    if (lvl) {\n        if (pos)\n            w[0] = st.r >> 3;\n        var opt = deo[lvl - 1];\n        var n = opt >> 13, c = opt & 8191;\n        var msk_1 = (1 << plvl) - 1;\n        //    prev 2-byte val map    curr 2-byte val map\n        var prev = st.p || new u16(32768), head = st.h || new u16(msk_1 + 1);\n        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;\n        var hsh = function (i) { return (dat[i] ^ (dat[i + 1] << bs1_1) ^ (dat[i + 2] << bs2_1)) & msk_1; };\n        // 24576 is an arbitrary number of maximum symbols per block\n        // 424 buffer for last block\n        var syms = new i32(25000);\n        // length/literal freq   distance freq\n        var lf = new u16(288), df = new u16(32);\n        //  l/lcnt  exbits  index          l/lind  waitdx          blkpos\n        var lc_1 = 0, eb = 0, i = st.i || 0, li = 0, wi = st.w || 0, bs = 0;\n        for (; i + 2 < s; ++i) {\n            // hash value\n            var hv = hsh(i);\n            // index mod 32768    previous index mod\n            var imod = i & 32767, pimod = head[hv];\n            prev[imod] = pimod;\n            head[hv] = imod;\n            // We always should modify head and prev, but only add symbols if\n            // this data is not yet processed (\"wait\" for wait index)\n            if (wi <= i) {\n                // bytes remaining\n                var rem = s - i;\n                if ((lc_1 > 7000 || li > 24576) && (rem > 423 || !lst)) {\n                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n                    li = lc_1 = eb = 0, bs = i;\n                    for (var j = 0; j < 286; ++j)\n                        lf[j] = 0;\n                    for (var j = 0; j < 30; ++j)\n                        df[j] = 0;\n                }\n                //  len    dist   chain\n                var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;\n                if (rem > 2 && hv == hsh(i - dif)) {\n                    var maxn = Math.min(n, rem) - 1;\n                    var maxd = Math.min(32767, i);\n                    // max possible length\n                    // not capped at dif because decompressors implement \"rolling\" index population\n                    var ml = Math.min(258, rem);\n                    while (dif <= maxd && --ch_1 && imod != pimod) {\n                        if (dat[i + l] == dat[i + l - dif]) {\n                            var nl = 0;\n                            for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)\n                                ;\n                            if (nl > l) {\n                                l = nl, d = dif;\n                                // break out early when we reach \"nice\" (we are satisfied enough)\n                                if (nl > maxn)\n                                    break;\n                                // now, find the rarest 2-byte sequence within this\n                                // length of literals and search for that instead.\n                                // Much faster than just using the start\n                                var mmd = Math.min(dif, nl - 2);\n                                var md = 0;\n                                for (var j = 0; j < mmd; ++j) {\n                                    var ti = i - dif + j & 32767;\n                                    var pti = prev[ti];\n                                    var cd = ti - pti & 32767;\n                                    if (cd > md)\n                                        md = cd, pimod = ti;\n                                }\n                            }\n                        }\n                        // check the previous match\n                        imod = pimod, pimod = prev[imod];\n                        dif += imod - pimod & 32767;\n                    }\n                }\n                // d will be nonzero only when a match was found\n                if (d) {\n                    // store both dist and len data in one int32\n                    // Make sure this is recognized as a len/dist with 28th bit (2^28)\n                    syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d];\n                    var lin = revfl[l] & 31, din = revfd[d] & 31;\n                    eb += fleb[lin] + fdeb[din];\n                    ++lf[257 + lin];\n                    ++df[din];\n                    wi = i + l;\n                    ++lc_1;\n                }\n                else {\n                    syms[li++] = dat[i];\n                    ++lf[dat[i]];\n                }\n            }\n        }\n        for (i = Math.max(i, wi); i < s; ++i) {\n            syms[li++] = dat[i];\n            ++lf[dat[i]];\n        }\n        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);\n        if (!lst) {\n            st.r = (pos & 7) | w[(pos / 8) | 0] << 3;\n            // shft(pos) now 1 less if pos & 7 != 0\n            pos -= 7;\n            st.h = head, st.p = prev, st.i = i, st.w = wi;\n        }\n    }\n    else {\n        for (var i = st.w || 0; i < s + lst; i += 65535) {\n            // end\n            var e = i + 65535;\n            if (e >= s) {\n                // write final block\n                w[(pos / 8) | 0] = lst;\n                e = s;\n            }\n            pos = wfblk(w, pos + 1, dat.subarray(i, e));\n        }\n        st.i = s;\n    }\n    return slc(o, 0, pre + shft(pos) + post);\n};\n// CRC32 table\nvar crct = /*#__PURE__*/ (function () {\n    var t = new Int32Array(256);\n    for (var i = 0; i < 256; ++i) {\n        var c = i, k = 9;\n        while (--k)\n            c = ((c & 1) && -306674912) ^ (c >>> 1);\n        t[i] = c;\n    }\n    return t;\n})();\n// CRC32\nvar crc = function () {\n    var c = -1;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var cr = c;\n            for (var i = 0; i < d.length; ++i)\n                cr = crct[(cr & 255) ^ d[i]] ^ (cr >>> 8);\n            c = cr;\n        },\n        d: function () { return ~c; }\n    };\n};\n// Adler32\nvar adler = function () {\n    var a = 1, b = 0;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var n = a, m = b;\n            var l = d.length | 0;\n            for (var i = 0; i != l;) {\n                var e = Math.min(i + 2655, l);\n                for (; i < e; ++i)\n                    m += n += d[i];\n                n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);\n            }\n            a = n, b = m;\n        },\n        d: function () {\n            a %= 65521, b %= 65521;\n            return (a & 255) << 24 | (a & 0xFF00) << 8 | (b & 255) << 8 | (b >> 8);\n        }\n    };\n};\n;\n// deflate with opts\nvar dopt = function (dat, opt, pre, post, st) {\n    if (!st) {\n        st = { l: 1 };\n        if (opt.dictionary) {\n            var dict = opt.dictionary.subarray(-32768);\n            var newDat = new u8(dict.length + dat.length);\n            newDat.set(dict);\n            newDat.set(dat, dict.length);\n            dat = newDat;\n            st.w = dict.length;\n        }\n    }\n    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? (st.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20) : (12 + opt.mem), pre, post, st);\n};\n// Walmart object spread\nvar mrg = function (a, b) {\n    var o = {};\n    for (var k in a)\n        o[k] = a[k];\n    for (var k in b)\n        o[k] = b[k];\n    return o;\n};\n// worker clone\n// This is possibly the craziest part of the entire codebase, despite how simple it may seem.\n// The only parameter to this function is a closure that returns an array of variables outside of the function scope.\n// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.\n// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).\n// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.\n// This took me three weeks to figure out how to do.\nvar wcln = function (fn, fnStr, td) {\n    var dt = fn();\n    var st = fn.toString();\n    var ks = st.slice(st.indexOf('[') + 1, st.lastIndexOf(']')).replace(/\\s+/g, '').split(',');\n    for (var i = 0; i < dt.length; ++i) {\n        var v = dt[i], k = ks[i];\n        if (typeof v == 'function') {\n            fnStr += ';' + k + '=';\n            var st_1 = v.toString();\n            if (v.prototype) {\n                // for global objects\n                if (st_1.indexOf('[native code]') != -1) {\n                    var spInd = st_1.indexOf(' ', 8) + 1;\n                    fnStr += st_1.slice(spInd, st_1.indexOf('(', spInd));\n                }\n                else {\n                    fnStr += st_1;\n                    for (var t in v.prototype)\n                        fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[t].toString();\n                }\n            }\n            else\n                fnStr += st_1;\n        }\n        else\n            td[k] = v;\n    }\n    return fnStr;\n};\nvar ch = [];\n// clone bufs\nvar cbfs = function (v) {\n    var tl = [];\n    for (var k in v) {\n        if (v[k].buffer) {\n            tl.push((v[k] = new v[k].constructor(v[k])).buffer);\n        }\n    }\n    return tl;\n};\n// use a worker to execute code\nvar wrkr = function (fns, init, id, cb) {\n    if (!ch[id]) {\n        var fnStr = '', td_1 = {}, m = fns.length - 1;\n        for (var i = 0; i < m; ++i)\n            fnStr = wcln(fns[i], fnStr, td_1);\n        ch[id] = { c: wcln(fns[m], fnStr, td_1), e: td_1 };\n    }\n    var td = mrg({}, ch[id].e);\n    return wk(ch[id].c + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + init.toString() + '}', id, td, cbfs(td), cb);\n};\n// base async inflate fn\nvar bInflt = function () { return [u8, u16, i32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gopt]; };\nvar bDflt = function () { return [u8, u16, i32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf]; };\n// gzip extra\nvar gze = function () { return [gzh, gzhl, wbytes, crc, crct]; };\n// gunzip extra\nvar guze = function () { return [gzs, gzl]; };\n// zlib extra\nvar zle = function () { return [zlh, wbytes, adler]; };\n// unzlib extra\nvar zule = function () { return [zls]; };\n// post buf\nvar pbf = function (msg) { return postMessage(msg, [msg.buffer]); };\n// get opts\nvar gopt = function (o) { return o && {\n    out: o.size && new u8(o.size),\n    dictionary: o.dictionary\n}; };\n// async helper\nvar cbify = function (dat, opts, fns, init, id, cb) {\n    var w = wrkr(fns, init, id, function (err, dat) {\n        w.terminate();\n        cb(err, dat);\n    });\n    w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);\n    return function () { w.terminate(); };\n};\n// auto stream\nvar astrm = function (strm) {\n    strm.ondata = function (dat, final) { return postMessage([dat, final], [dat.buffer]); };\n    return function (ev) {\n        if (ev.data.length) {\n            strm.push(ev.data[0], ev.data[1]);\n            postMessage([ev.data[0].length]);\n        }\n        else\n            strm.flush();\n    };\n};\n// async stream attach\nvar astrmify = function (fns, strm, opts, init, id, flush, ext) {\n    var t;\n    var w = wrkr(fns, init, id, function (err, dat) {\n        if (err)\n            w.terminate(), strm.ondata.call(strm, err);\n        else if (!Array.isArray(dat))\n            ext(dat);\n        else if (dat.length == 1) {\n            strm.queuedSize -= dat[0];\n            if (strm.ondrain)\n                strm.ondrain(dat[0]);\n        }\n        else {\n            if (dat[1])\n                w.terminate();\n            strm.ondata.call(strm, err, dat[0], dat[1]);\n        }\n    });\n    w.postMessage(opts);\n    strm.queuedSize = 0;\n    strm.push = function (d, f) {\n        if (!strm.ondata)\n            err(5);\n        if (t)\n            strm.ondata(err(4, 0, 1), null, !!f);\n        strm.queuedSize += d.length;\n        w.postMessage([d, t = f], [d.buffer]);\n    };\n    strm.terminate = function () { w.terminate(); };\n    if (flush) {\n        strm.flush = function () { w.postMessage([]); };\n    }\n};\n// read 2 bytes\nvar b2 = function (d, b) { return d[b] | (d[b + 1] << 8); };\n// read 4 bytes\nvar b4 = function (d, b) { return (d[b] | (d[b + 1] << 8) | (d[b + 2] << 16) | (d[b + 3] << 24)) >>> 0; };\nvar b8 = function (d, b) { return b4(d, b) + (b4(d, b + 4) * 4294967296); };\n// write bytes\nvar wbytes = function (d, b, v) {\n    for (; v; ++b)\n        d[b] = v, v >>>= 8;\n};\n// gzip header\nvar gzh = function (c, o) {\n    var fn = o.filename;\n    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix\n    if (o.mtime != 0)\n        wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));\n    if (fn) {\n        c[3] = 8;\n        for (var i = 0; i <= fn.length; ++i)\n            c[i + 10] = fn.charCodeAt(i);\n    }\n};\n// gzip footer: -8 to -4 = CRC, -4 to -0 is length\n// gzip start\nvar gzs = function (d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n        err(6, 'invalid gzip data');\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4)\n        st += (d[10] | d[11] << 8) + 2;\n    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\n        ;\n    return st + (flg & 2);\n};\n// gzip length\nvar gzl = function (d) {\n    var l = d.length;\n    return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;\n};\n// gzip header length\nvar gzhl = function (o) { return 10 + (o.filename ? o.filename.length + 1 : 0); };\n// zlib header\nvar zlh = function (c, o) {\n    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\n    c[0] = 120, c[1] = (fl << 6) | (o.dictionary && 32);\n    c[1] |= 31 - ((c[0] << 8) | c[1]) % 31;\n    if (o.dictionary) {\n        var h = adler();\n        h.p(o.dictionary);\n        wbytes(c, 2, h.d());\n    }\n};\n// zlib start\nvar zls = function (d, dict) {\n    if ((d[0] & 15) != 8 || (d[0] >> 4) > 7 || ((d[0] << 8 | d[1]) % 31))\n        err(6, 'invalid zlib data');\n    if ((d[1] >> 5 & 1) == +!dict)\n        err(6, 'invalid zlib data: ' + (d[1] & 32 ? 'need' : 'unexpected') + ' dictionary');\n    return (d[1] >> 3 & 4) + 2;\n};\nfunction StrmOpt(opts, cb) {\n    if (typeof opts == 'function')\n        cb = opts, opts = {};\n    this.ondata = cb;\n    return opts;\n}\n/**\n * Streaming DEFLATE compression\n */\nvar Deflate = /*#__PURE__*/ (function () {\n    function Deflate(opts, cb) {\n        if (typeof opts == 'function')\n            cb = opts, opts = {};\n        this.ondata = cb;\n        this.o = opts || {};\n        this.s = { l: 0, i: 32768, w: 32768, z: 32768 };\n        // Buffer length must always be 0 mod 32768 for index calculations to be correct when modifying head and prev\n        // 98304 = 32768 (lookback) + 65536 (common chunk size)\n        this.b = new u8(98304);\n        if (this.o.dictionary) {\n            var dict = this.o.dictionary.subarray(-32768);\n            this.b.set(dict, 32768 - dict.length);\n            this.s.i = 32768 - dict.length;\n        }\n    }\n    Deflate.prototype.p = function (c, f) {\n        this.ondata(dopt(c, this.o, 0, 0, this.s), f);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Deflate.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (this.s.l)\n            err(4);\n        var endLen = chunk.length + this.s.z;\n        if (endLen > this.b.length) {\n            if (endLen > 2 * this.b.length - 32768) {\n                var newBuf = new u8(endLen & -32768);\n                newBuf.set(this.b.subarray(0, this.s.z));\n                this.b = newBuf;\n            }\n            var split = this.b.length - this.s.z;\n            this.b.set(chunk.subarray(0, split), this.s.z);\n            this.s.z = this.b.length;\n            this.p(this.b, false);\n            this.b.set(this.b.subarray(-32768));\n            this.b.set(chunk.subarray(split), 32768);\n            this.s.z = chunk.length - split + 32768;\n            this.s.i = 32766, this.s.w = 32768;\n        }\n        else {\n            this.b.set(chunk, this.s.z);\n            this.s.z += chunk.length;\n        }\n        this.s.l = final & 1;\n        if (this.s.z > this.s.w + 8191 || final) {\n            this.p(this.b, final || false);\n            this.s.w = this.s.i, this.s.i -= 2;\n        }\n    };\n    /**\n     * Flushes buffered uncompressed data. Useful to immediately retrieve the\n     * deflated output for small inputs.\n     */\n    Deflate.prototype.flush = function () {\n        if (!this.ondata)\n            err(5);\n        if (this.s.l)\n            err(4);\n        this.p(this.b, false);\n        this.s.w = this.s.i, this.s.i -= 2;\n    };\n    return Deflate;\n}());\nexport { Deflate };\n/**\n * Asynchronous streaming DEFLATE compression\n */\nvar AsyncDeflate = /*#__PURE__*/ (function () {\n    function AsyncDeflate(opts, cb) {\n        astrmify([\n            bDflt,\n            function () { return [astrm, Deflate]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Deflate(ev.data);\n            onmessage = astrm(strm);\n        }, 6, 1);\n    }\n    return AsyncDeflate;\n}());\nexport { AsyncDeflate };\nexport function deflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n    ], function (ev) { return pbf(deflateSync(ev.data[0], ev.data[1])); }, 0, cb);\n}\n/**\n * Compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param opts The compression options\n * @returns The deflated version of the data\n */\nexport function deflateSync(data, opts) {\n    return dopt(data, opts || {}, 0, 0);\n}\n/**\n * Streaming DEFLATE decompression\n */\nvar Inflate = /*#__PURE__*/ (function () {\n    function Inflate(opts, cb) {\n        // no StrmOpt here to avoid adding to workerizer\n        if (typeof opts == 'function')\n            cb = opts, opts = {};\n        this.ondata = cb;\n        var dict = opts && opts.dictionary && opts.dictionary.subarray(-32768);\n        this.s = { i: 0, b: dict ? dict.length : 0 };\n        this.o = new u8(32768);\n        this.p = new u8(0);\n        if (dict)\n            this.o.set(dict);\n    }\n    Inflate.prototype.e = function (c) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        if (!this.p.length)\n            this.p = c;\n        else if (c.length) {\n            var n = new u8(this.p.length + c.length);\n            n.set(this.p), n.set(c, this.p.length), this.p = n;\n        }\n    };\n    Inflate.prototype.c = function (final) {\n        this.s.i = +(this.d = final || false);\n        var bts = this.s.b;\n        var dt = inflt(this.p, this.s, this.o);\n        this.ondata(slc(dt, bts, this.s.b), this.d);\n        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n        this.p = slc(this.p, (this.s.p / 8) | 0), this.s.p &= 7;\n    };\n    /**\n     * Pushes a chunk to be inflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the final chunk\n     */\n    Inflate.prototype.push = function (chunk, final) {\n        this.e(chunk), this.c(final);\n    };\n    return Inflate;\n}());\nexport { Inflate };\n/**\n * Asynchronous streaming DEFLATE decompression\n */\nvar AsyncInflate = /*#__PURE__*/ (function () {\n    function AsyncInflate(opts, cb) {\n        astrmify([\n            bInflt,\n            function () { return [astrm, Inflate]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Inflate(ev.data);\n            onmessage = astrm(strm);\n        }, 7, 0);\n    }\n    return AsyncInflate;\n}());\nexport { AsyncInflate };\nexport function inflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt\n    ], function (ev) { return pbf(inflateSync(ev.data[0], gopt(ev.data[1]))); }, 1, cb);\n}\n/**\n * Expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */\nexport function inflateSync(data, opts) {\n    return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);\n}\n// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.\n/**\n * Streaming GZIP compression\n */\nvar Gzip = /*#__PURE__*/ (function () {\n    function Gzip(opts, cb) {\n        this.c = crc();\n        this.l = 0;\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gzip.prototype.push = function (chunk, final) {\n        this.c.p(chunk);\n        this.l += chunk.length;\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Gzip.prototype.p = function (c, f) {\n        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, this.s);\n        if (this.v)\n            gzh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);\n        this.ondata(raw, f);\n    };\n    /**\n     * Flushes buffered uncompressed data. Useful to immediately retrieve the\n     * GZIPped output for small inputs.\n     */\n    Gzip.prototype.flush = function () {\n        Deflate.prototype.flush.call(this);\n    };\n    return Gzip;\n}());\nexport { Gzip };\n/**\n * Asynchronous streaming GZIP compression\n */\nvar AsyncGzip = /*#__PURE__*/ (function () {\n    function AsyncGzip(opts, cb) {\n        astrmify([\n            bDflt,\n            gze,\n            function () { return [astrm, Deflate, Gzip]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Gzip(ev.data);\n            onmessage = astrm(strm);\n        }, 8, 1);\n    }\n    return AsyncGzip;\n}());\nexport { AsyncGzip };\nexport function gzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n        gze,\n        function () { return [gzipSync]; }\n    ], function (ev) { return pbf(gzipSync(ev.data[0], ev.data[1])); }, 2, cb);\n}\n/**\n * Compresses data with GZIP\n * @param data The data to compress\n * @param opts The compression options\n * @returns The gzipped version of the data\n */\nexport function gzipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var c = crc(), l = data.length;\n    c.p(data);\n    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;\n    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;\n}\n/**\n * Streaming single or multi-member GZIP decompression\n */\nvar Gunzip = /*#__PURE__*/ (function () {\n    function Gunzip(opts, cb) {\n        this.v = 1;\n        this.r = 0;\n        Inflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GUNZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gunzip.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        this.r += chunk.length;\n        if (this.v) {\n            var p = this.p.subarray(this.v - 1);\n            var s = p.length > 3 ? gzs(p) : 4;\n            if (s > p.length) {\n                if (!final)\n                    return;\n            }\n            else if (this.v > 1 && this.onmember) {\n                this.onmember(this.r - p.length);\n            }\n            this.p = p.subarray(s), this.v = 0;\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n        // process concatenated GZIP\n        if (this.s.f && !this.s.l && !final) {\n            this.v = shft(this.s.p) + 9;\n            this.s = { i: 0 };\n            this.o = new u8(0);\n            this.push(new u8(0), final);\n        }\n    };\n    return Gunzip;\n}());\nexport { Gunzip };\n/**\n * Asynchronous streaming single or multi-member GZIP decompression\n */\nvar AsyncGunzip = /*#__PURE__*/ (function () {\n    function AsyncGunzip(opts, cb) {\n        var _this = this;\n        astrmify([\n            bInflt,\n            guze,\n            function () { return [astrm, Inflate, Gunzip]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Gunzip(ev.data);\n            strm.onmember = function (offset) { return postMessage(offset); };\n            onmessage = astrm(strm);\n        }, 9, 0, function (offset) { return _this.onmember && _this.onmember(offset); });\n    }\n    return AsyncGunzip;\n}());\nexport { AsyncGunzip };\nexport function gunzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt,\n        guze,\n        function () { return [gunzipSync]; }\n    ], function (ev) { return pbf(gunzipSync(ev.data[0], ev.data[1])); }, 3, cb);\n}\n/**\n * Expands GZIP data\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */\nexport function gunzipSync(data, opts) {\n    var st = gzs(data);\n    if (st + 8 > data.length)\n        err(6, 'invalid gzip data');\n    return inflt(data.subarray(st, -8), { i: 2 }, opts && opts.out || new u8(gzl(data)), opts && opts.dictionary);\n}\n/**\n * Streaming Zlib compression\n */\nvar Zlib = /*#__PURE__*/ (function () {\n    function Zlib(opts, cb) {\n        this.c = adler();\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be zlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Zlib.prototype.push = function (chunk, final) {\n        this.c.p(chunk);\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Zlib.prototype.p = function (c, f) {\n        var raw = dopt(c, this.o, this.v && (this.o.dictionary ? 6 : 2), f && 4, this.s);\n        if (this.v)\n            zlh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 4, this.c.d());\n        this.ondata(raw, f);\n    };\n    /**\n     * Flushes buffered uncompressed data. Useful to immediately retrieve the\n     * zlibbed output for small inputs.\n     */\n    Zlib.prototype.flush = function () {\n        Deflate.prototype.flush.call(this);\n    };\n    return Zlib;\n}());\nexport { Zlib };\n/**\n * Asynchronous streaming Zlib compression\n */\nvar AsyncZlib = /*#__PURE__*/ (function () {\n    function AsyncZlib(opts, cb) {\n        astrmify([\n            bDflt,\n            zle,\n            function () { return [astrm, Deflate, Zlib]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Zlib(ev.data);\n            onmessage = astrm(strm);\n        }, 10, 1);\n    }\n    return AsyncZlib;\n}());\nexport { AsyncZlib };\nexport function zlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n        zle,\n        function () { return [zlibSync]; }\n    ], function (ev) { return pbf(zlibSync(ev.data[0], ev.data[1])); }, 4, cb);\n}\n/**\n * Compress data with Zlib\n * @param data The data to compress\n * @param opts The compression options\n * @returns The zlib-compressed version of the data\n */\nexport function zlibSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var a = adler();\n    a.p(data);\n    var d = dopt(data, opts, opts.dictionary ? 6 : 2, 4);\n    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;\n}\n/**\n * Streaming Zlib decompression\n */\nvar Unzlib = /*#__PURE__*/ (function () {\n    function Unzlib(opts, cb) {\n        Inflate.call(this, opts, cb);\n        this.v = opts && opts.dictionary ? 2 : 1;\n    }\n    /**\n     * Pushes a chunk to be unzlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzlib.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            if (this.p.length < 6 && !final)\n                return;\n            this.p = this.p.subarray(zls(this.p, this.v - 1)), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 4)\n                err(6, 'invalid zlib data');\n            this.p = this.p.subarray(0, -4);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Unzlib;\n}());\nexport { Unzlib };\n/**\n * Asynchronous streaming Zlib decompression\n */\nvar AsyncUnzlib = /*#__PURE__*/ (function () {\n    function AsyncUnzlib(opts, cb) {\n        astrmify([\n            bInflt,\n            zule,\n            function () { return [astrm, Inflate, Unzlib]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Unzlib(ev.data);\n            onmessage = astrm(strm);\n        }, 11, 0);\n    }\n    return AsyncUnzlib;\n}());\nexport { AsyncUnzlib };\nexport function unzlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt,\n        zule,\n        function () { return [unzlibSync]; }\n    ], function (ev) { return pbf(unzlibSync(ev.data[0], gopt(ev.data[1]))); }, 5, cb);\n}\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */\nexport function unzlibSync(data, opts) {\n    return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), { i: 2 }, opts && opts.out, opts && opts.dictionary);\n}\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzip as compress, AsyncGzip as AsyncCompress };\nexport { gzipSync as compressSync, Gzip as Compress };\n/**\n * Streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar Decompress = /*#__PURE__*/ (function () {\n    function Decompress(opts, cb) {\n        this.o = StrmOpt.call(this, opts, cb) || {};\n        this.G = Gunzip;\n        this.I = Inflate;\n        this.Z = Unzlib;\n    }\n    // init substream\n    // overriden by AsyncDecompress\n    Decompress.prototype.i = function () {\n        var _this = this;\n        this.s.ondata = function (dat, final) {\n            _this.ondata(dat, final);\n        };\n    };\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Decompress.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (!this.s) {\n            if (this.p && this.p.length) {\n                var n = new u8(this.p.length + chunk.length);\n                n.set(this.p), n.set(chunk, this.p.length);\n            }\n            else\n                this.p = chunk;\n            if (this.p.length > 2) {\n                this.s = (this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8)\n                    ? new this.G(this.o)\n                    : ((this.p[0] & 15) != 8 || (this.p[0] >> 4) > 7 || ((this.p[0] << 8 | this.p[1]) % 31))\n                        ? new this.I(this.o)\n                        : new this.Z(this.o);\n                this.i();\n                this.s.push(this.p, final);\n                this.p = null;\n            }\n        }\n        else\n            this.s.push(chunk, final);\n    };\n    return Decompress;\n}());\nexport { Decompress };\n/**\n * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar AsyncDecompress = /*#__PURE__*/ (function () {\n    function AsyncDecompress(opts, cb) {\n        Decompress.call(this, opts, cb);\n        this.queuedSize = 0;\n        this.G = AsyncGunzip;\n        this.I = AsyncInflate;\n        this.Z = AsyncUnzlib;\n    }\n    AsyncDecompress.prototype.i = function () {\n        var _this = this;\n        this.s.ondata = function (err, dat, final) {\n            _this.ondata(err, dat, final);\n        };\n        this.s.ondrain = function (size) {\n            _this.queuedSize -= size;\n            if (_this.ondrain)\n                _this.ondrain(size);\n        };\n    };\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncDecompress.prototype.push = function (chunk, final) {\n        this.queuedSize += chunk.length;\n        Decompress.prototype.push.call(this, chunk, final);\n    };\n    return AsyncDecompress;\n}());\nexport { AsyncDecompress };\nexport function decompress(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzip(data, opts, cb)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflate(data, opts, cb)\n            : unzlib(data, opts, cb);\n}\n/**\n * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */\nexport function decompressSync(data, opts) {\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzipSync(data, opts)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflateSync(data, opts)\n            : unzlibSync(data, opts);\n}\n// flatten a directory structure\nvar fltn = function (d, p, t, o) {\n    for (var k in d) {\n        var val = d[k], n = p + k, op = o;\n        if (Array.isArray(val))\n            op = mrg(o, val[1]), val = val[0];\n        if (val instanceof u8)\n            t[n] = [val, op];\n        else {\n            t[n += '/'] = [new u8(0), op];\n            fltn(val, n, t, o);\n        }\n    }\n};\n// text encoder\nvar te = typeof TextEncoder != 'undefined' && /*#__PURE__*/ new TextEncoder();\n// text decoder\nvar td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();\n// text decoder stream\nvar tds = 0;\ntry {\n    td.decode(et, { stream: true });\n    tds = 1;\n}\ncatch (e) { }\n// decode UTF8\nvar dutf8 = function (d) {\n    for (var r = '', i = 0;;) {\n        var c = d[i++];\n        var eb = (c > 127) + (c > 223) + (c > 239);\n        if (i + eb > d.length)\n            return { s: r, r: slc(d, i - 1) };\n        if (!eb)\n            r += String.fromCharCode(c);\n        else if (eb == 3) {\n            c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63)) - 65536,\n                r += String.fromCharCode(55296 | (c >> 10), 56320 | (c & 1023));\n        }\n        else if (eb & 1)\n            r += String.fromCharCode((c & 31) << 6 | (d[i++] & 63));\n        else\n            r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63));\n    }\n};\n/**\n * Streaming UTF-8 decoding\n */\nvar DecodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is decoded\n     */\n    function DecodeUTF8(cb) {\n        this.ondata = cb;\n        if (tds)\n            this.t = new TextDecoder();\n        else\n            this.p = et;\n    }\n    /**\n     * Pushes a chunk to be decoded from UTF-8 binary\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    DecodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        final = !!final;\n        if (this.t) {\n            this.ondata(this.t.decode(chunk, { stream: true }), final);\n            if (final) {\n                if (this.t.decode().length)\n                    err(8);\n                this.t = null;\n            }\n            return;\n        }\n        if (!this.p)\n            err(4);\n        var dat = new u8(this.p.length + chunk.length);\n        dat.set(this.p);\n        dat.set(chunk, this.p.length);\n        var _a = dutf8(dat), s = _a.s, r = _a.r;\n        if (final) {\n            if (r.length)\n                err(8);\n            this.p = null;\n        }\n        else\n            this.p = r;\n        this.ondata(s, final);\n    };\n    return DecodeUTF8;\n}());\nexport { DecodeUTF8 };\n/**\n * Streaming UTF-8 encoding\n */\nvar EncodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is encoded\n     */\n    function EncodeUTF8(cb) {\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be encoded to UTF-8\n     * @param chunk The string data to push\n     * @param final Whether this is the last chunk\n     */\n    EncodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        this.ondata(strToU8(chunk), this.d = final || false);\n    };\n    return EncodeUTF8;\n}());\nexport { EncodeUTF8 };\n/**\n * Converts a string into a Uint8Array for use with compression/decompression methods\n * @param str The string to encode\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless decoding a binary string.\n * @returns The string encoded in UTF-8/Latin-1 binary\n */\nexport function strToU8(str, latin1) {\n    if (latin1) {\n        var ar_1 = new u8(str.length);\n        for (var i = 0; i < str.length; ++i)\n            ar_1[i] = str.charCodeAt(i);\n        return ar_1;\n    }\n    if (te)\n        return te.encode(str);\n    var l = str.length;\n    var ar = new u8(str.length + (str.length >> 1));\n    var ai = 0;\n    var w = function (v) { ar[ai++] = v; };\n    for (var i = 0; i < l; ++i) {\n        if (ai + 5 > ar.length) {\n            var n = new u8(ai + 8 + ((l - i) << 1));\n            n.set(ar);\n            ar = n;\n        }\n        var c = str.charCodeAt(i);\n        if (c < 128 || latin1)\n            w(c);\n        else if (c < 2048)\n            w(192 | (c >> 6)), w(128 | (c & 63));\n        else if (c > 55295 && c < 57344)\n            c = 65536 + (c & 1023 << 10) | (str.charCodeAt(++i) & 1023),\n                w(240 | (c >> 18)), w(128 | ((c >> 12) & 63)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n        else\n            w(224 | (c >> 12)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n    }\n    return slc(ar, 0, ai);\n}\n/**\n * Converts a Uint8Array to a string\n * @param dat The data to decode to string\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless encoding to binary string.\n * @returns The original UTF-8/Latin-1 string\n */\nexport function strFromU8(dat, latin1) {\n    if (latin1) {\n        var r = '';\n        for (var i = 0; i < dat.length; i += 16384)\n            r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));\n        return r;\n    }\n    else if (td) {\n        return td.decode(dat);\n    }\n    else {\n        var _a = dutf8(dat), s = _a.s, r = _a.r;\n        if (r.length)\n            err(8);\n        return s;\n    }\n}\n;\n// deflate bit flag\nvar dbf = function (l) { return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0; };\n// skip local zip header\nvar slzh = function (d, b) { return b + 30 + b2(d, b + 26) + b2(d, b + 28); };\n// read zip header\nvar zh = function (d, b, z) {\n    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\n    var _a = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a[0], su = _a[1], off = _a[2];\n    return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];\n};\n// read zip64 extra field\nvar z64e = function (d, b) {\n    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))\n        ;\n    return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];\n};\n// extra field length\nvar exfl = function (ex) {\n    var le = 0;\n    if (ex) {\n        for (var k in ex) {\n            var l = ex[k].length;\n            if (l > 65535)\n                err(9);\n            le += l + 4;\n        }\n    }\n    return le;\n};\n// write zip header\nvar wzh = function (d, b, f, fn, u, c, ce, co) {\n    var fl = fn.length, ex = f.extra, col = co && co.length;\n    var exl = exfl(ex);\n    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;\n    if (ce != null)\n        d[b++] = 20, d[b++] = f.os;\n    d[b] = 20, b += 2; // spec compliance? what's that?\n    d[b++] = (f.flag << 1) | (c < 0 && 8), d[b++] = u && 8;\n    d[b++] = f.compression & 255, d[b++] = f.compression >> 8;\n    var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;\n    if (y < 0 || y > 119)\n        err(10);\n    wbytes(d, b, (y << 25) | ((dt.getMonth() + 1) << 21) | (dt.getDate() << 16) | (dt.getHours() << 11) | (dt.getMinutes() << 5) | (dt.getSeconds() >> 1)), b += 4;\n    if (c != -1) {\n        wbytes(d, b, f.crc);\n        wbytes(d, b + 4, c < 0 ? -c - 2 : c);\n        wbytes(d, b + 8, f.size);\n    }\n    wbytes(d, b + 12, fl);\n    wbytes(d, b + 14, exl), b += 16;\n    if (ce != null) {\n        wbytes(d, b, col);\n        wbytes(d, b + 6, f.attrs);\n        wbytes(d, b + 10, ce), b += 14;\n    }\n    d.set(fn, b);\n    b += fl;\n    if (exl) {\n        for (var k in ex) {\n            var exf = ex[k], l = exf.length;\n            wbytes(d, b, +k);\n            wbytes(d, b + 2, l);\n            d.set(exf, b + 4), b += 4 + l;\n        }\n    }\n    if (col)\n        d.set(co, b), b += col;\n    return b;\n};\n// write zip footer (end of central directory)\nvar wzf = function (o, b, c, d, e) {\n    wbytes(o, b, 0x6054B50); // skip disk\n    wbytes(o, b + 8, c);\n    wbytes(o, b + 10, c);\n    wbytes(o, b + 12, d);\n    wbytes(o, b + 16, e);\n};\n/**\n * A pass-through stream to keep data uncompressed in a ZIP archive.\n */\nvar ZipPassThrough = /*#__PURE__*/ (function () {\n    /**\n     * Creates a pass-through stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     */\n    function ZipPassThrough(filename) {\n        this.filename = filename;\n        this.c = crc();\n        this.size = 0;\n        this.compression = 0;\n    }\n    /**\n     * Processes a chunk and pushes to the output stream. You can override this\n     * method in a subclass for custom behavior, but by default this passes\n     * the data through. You must call this.ondata(err, chunk, final) at some\n     * point in this method.\n     * @param chunk The chunk to process\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.process = function (chunk, final) {\n        this.ondata(null, chunk, final);\n    };\n    /**\n     * Pushes a chunk to be added. If you are subclassing this with a custom\n     * compression algorithm, note that you must push data from the source\n     * file only, pre-compression.\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        this.c.p(chunk);\n        this.size += chunk.length;\n        if (final)\n            this.crc = this.c.d();\n        this.process(chunk, final || false);\n    };\n    return ZipPassThrough;\n}());\nexport { ZipPassThrough };\n// I don't extend because TypeScript extension adds 1kB of runtime bloat\n/**\n * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate\n * for better performance\n */\nvar ZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function ZipDeflate(filename, opts) {\n        var _this = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new Deflate(opts, function (dat, final) {\n            _this.ondata(null, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n    }\n    ZipDeflate.prototype.process = function (chunk, final) {\n        try {\n            this.d.push(chunk, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return ZipDeflate;\n}());\nexport { ZipDeflate };\n/**\n * Asynchronous streaming DEFLATE compression for ZIP archives\n */\nvar AsyncZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function AsyncZipDeflate(filename, opts) {\n        var _this = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new AsyncDeflate(opts, function (err, dat, final) {\n            _this.ondata(err, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n        this.terminate = this.d.terminate;\n    }\n    AsyncZipDeflate.prototype.process = function (chunk, final) {\n        this.d.push(chunk, final);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return AsyncZipDeflate;\n}());\nexport { AsyncZipDeflate };\n// TODO: Better tree shaking\n/**\n * A zippable archive to which files can incrementally be added\n */\nvar Zip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an empty ZIP archive to which files can be added\n     * @param cb The callback to call whenever data for the generated ZIP archive\n     *           is available\n     */\n    function Zip(cb) {\n        this.ondata = cb;\n        this.u = [];\n        this.d = 1;\n    }\n    /**\n     * Adds a file to the ZIP archive\n     * @param file The file stream to add\n     */\n    Zip.prototype.add = function (file) {\n        var _this = this;\n        if (!this.ondata)\n            err(5);\n        // finishing or finished\n        if (this.d & 2)\n            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, false);\n        else {\n            var f = strToU8(file.filename), fl_1 = f.length;\n            var com = file.comment, o = com && strToU8(com);\n            var u = fl_1 != file.filename.length || (o && (com.length != o.length));\n            var hl_1 = fl_1 + exfl(file.extra) + 30;\n            if (fl_1 > 65535)\n                this.ondata(err(11, 0, 1), null, false);\n            var header = new u8(hl_1);\n            wzh(header, 0, file, f, u, -1);\n            var chks_1 = [header];\n            var pAll_1 = function () {\n                for (var _i = 0, chks_2 = chks_1; _i < chks_2.length; _i++) {\n                    var chk = chks_2[_i];\n                    _this.ondata(null, chk, false);\n                }\n                chks_1 = [];\n            };\n            var tr_1 = this.d;\n            this.d = 0;\n            var ind_1 = this.u.length;\n            var uf_1 = mrg(file, {\n                f: f,\n                u: u,\n                o: o,\n                t: function () {\n                    if (file.terminate)\n                        file.terminate();\n                },\n                r: function () {\n                    pAll_1();\n                    if (tr_1) {\n                        var nxt = _this.u[ind_1 + 1];\n                        if (nxt)\n                            nxt.r();\n                        else\n                            _this.d = 1;\n                    }\n                    tr_1 = 1;\n                }\n            });\n            var cl_1 = 0;\n            file.ondata = function (err, dat, final) {\n                if (err) {\n                    _this.ondata(err, dat, final);\n                    _this.terminate();\n                }\n                else {\n                    cl_1 += dat.length;\n                    chks_1.push(dat);\n                    if (final) {\n                        var dd = new u8(16);\n                        wbytes(dd, 0, 0x8074B50);\n                        wbytes(dd, 4, file.crc);\n                        wbytes(dd, 8, cl_1);\n                        wbytes(dd, 12, file.size);\n                        chks_1.push(dd);\n                        uf_1.c = cl_1, uf_1.b = hl_1 + cl_1 + 16, uf_1.crc = file.crc, uf_1.size = file.size;\n                        if (tr_1)\n                            uf_1.r();\n                        tr_1 = 1;\n                    }\n                    else if (tr_1)\n                        pAll_1();\n                }\n            };\n            this.u.push(uf_1);\n        }\n    };\n    /**\n     * Ends the process of adding files and prepares to emit the final chunks.\n     * This *must* be called after adding all desired files for the resulting\n     * ZIP file to work properly.\n     */\n    Zip.prototype.end = function () {\n        var _this = this;\n        if (this.d & 2) {\n            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, true);\n            return;\n        }\n        if (this.d)\n            this.e();\n        else\n            this.u.push({\n                r: function () {\n                    if (!(_this.d & 1))\n                        return;\n                    _this.u.splice(-1, 1);\n                    _this.e();\n                },\n                t: function () { }\n            });\n        this.d = 3;\n    };\n    Zip.prototype.e = function () {\n        var bt = 0, l = 0, tl = 0;\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);\n        }\n        var out = new u8(tl + 22);\n        for (var _b = 0, _c = this.u; _b < _c.length; _b++) {\n            var f = _c[_b];\n            wzh(out, bt, f, f.f, f.u, -f.c - 2, l, f.o);\n            bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;\n        }\n        wzf(out, bt, this.u.length, tl, l);\n        this.ondata(null, out, true);\n        this.d = 2;\n    };\n    /**\n     * A method to terminate any internal workers used by the stream. Subsequent\n     * calls to add() will fail.\n     */\n    Zip.prototype.terminate = function () {\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            f.t();\n        }\n        this.d = 2;\n    };\n    return Zip;\n}());\nexport { Zip };\nexport function zip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    var r = {};\n    fltn(data, '', r, opts);\n    var k = Object.keys(r);\n    var lft = k.length, o = 0, tot = 0;\n    var slft = lft, files = new Array(lft);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var cbd = function (a, b) {\n        mt(function () { cb(a, b); });\n    };\n    mt(function () { cbd = cb; });\n    var cbf = function () {\n        var out = new u8(tot + 22), oe = o, cdl = tot - o;\n        tot = 0;\n        for (var i = 0; i < slft; ++i) {\n            var f = files[i];\n            try {\n                var l = f.c.length;\n                wzh(out, tot, f, f.f, f.u, l);\n                var badd = 30 + f.f.length + exfl(f.extra);\n                var loc = tot + badd;\n                out.set(f.c, loc);\n                wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;\n            }\n            catch (e) {\n                return cbd(e, null);\n            }\n        }\n        wzf(out, o, files.length, cdl, oe);\n        cbd(null, out);\n    };\n    if (!lft)\n        cbf();\n    var _loop_1 = function (i) {\n        var fn = k[i];\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var c = crc(), size = file.length;\n        c.p(file);\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        var compression = p.level == 0 ? 0 : 8;\n        var cbl = function (e, d) {\n            if (e) {\n                tAll();\n                cbd(e, null);\n            }\n            else {\n                var l = d.length;\n                files[i] = mrg(p, {\n                    size: size,\n                    crc: c.d(),\n                    c: d,\n                    f: f,\n                    m: m,\n                    u: s != fn.length || (m && (com.length != ms)),\n                    compression: compression\n                });\n                o += 30 + s + exl + l;\n                tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n                if (!--lft)\n                    cbf();\n            }\n        };\n        if (s > 65535)\n            cbl(err(11, 0, 1), null);\n        if (!compression)\n            cbl(null, file);\n        else if (size < 160000) {\n            try {\n                cbl(null, deflateSync(file, p));\n            }\n            catch (e) {\n                cbl(e, null);\n            }\n        }\n        else\n            term.push(deflate(file, p, cbl));\n    };\n    // Cannot use lft because it can decrease\n    for (var i = 0; i < slft; ++i) {\n        _loop_1(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously creates a ZIP file. Prefer using `zip` for better performance\n * with more than one file.\n * @param data The directory structure for the ZIP archive\n * @param opts The main options, merged with per-file options\n * @returns The generated ZIP archive\n */\nexport function zipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var r = {};\n    var files = [];\n    fltn(data, '', r, opts);\n    var o = 0;\n    var tot = 0;\n    for (var fn in r) {\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var compression = p.level == 0 ? 0 : 8;\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        if (s > 65535)\n            err(11);\n        var d = compression ? deflateSync(file, p) : file, l = d.length;\n        var c = crc();\n        c.p(file);\n        files.push(mrg(p, {\n            size: file.length,\n            crc: c.d(),\n            c: d,\n            f: f,\n            m: m,\n            u: s != fn.length || (m && (com.length != ms)),\n            o: o,\n            compression: compression\n        }));\n        o += 30 + s + exl + l;\n        tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n    }\n    var out = new u8(tot + 22), oe = o, cdl = tot - o;\n    for (var i = 0; i < files.length; ++i) {\n        var f = files[i];\n        wzh(out, f.o, f, f.f, f.u, f.c.length);\n        var badd = 30 + f.f.length + exfl(f.extra);\n        out.set(f.c, f.o + badd);\n        wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);\n    }\n    wzf(out, o, files.length, cdl, oe);\n    return out;\n}\n/**\n * Streaming pass-through decompression for ZIP archives\n */\nvar UnzipPassThrough = /*#__PURE__*/ (function () {\n    function UnzipPassThrough() {\n    }\n    UnzipPassThrough.prototype.push = function (data, final) {\n        this.ondata(null, data, final);\n    };\n    UnzipPassThrough.compression = 0;\n    return UnzipPassThrough;\n}());\nexport { UnzipPassThrough };\n/**\n * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for\n * better performance.\n */\nvar UnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function UnzipInflate() {\n        var _this = this;\n        this.i = new Inflate(function (dat, final) {\n            _this.ondata(null, dat, final);\n        });\n    }\n    UnzipInflate.prototype.push = function (data, final) {\n        try {\n            this.i.push(data, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    UnzipInflate.compression = 8;\n    return UnzipInflate;\n}());\nexport { UnzipInflate };\n/**\n * Asynchronous streaming DEFLATE decompression for ZIP archives\n */\nvar AsyncUnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function AsyncUnzipInflate(_, sz) {\n        var _this = this;\n        if (sz < 320000) {\n            this.i = new Inflate(function (dat, final) {\n                _this.ondata(null, dat, final);\n            });\n        }\n        else {\n            this.i = new AsyncInflate(function (err, dat, final) {\n                _this.ondata(err, dat, final);\n            });\n            this.terminate = this.i.terminate;\n        }\n    }\n    AsyncUnzipInflate.prototype.push = function (data, final) {\n        if (this.i.terminate)\n            data = slc(data, 0);\n        this.i.push(data, final);\n    };\n    AsyncUnzipInflate.compression = 8;\n    return AsyncUnzipInflate;\n}());\nexport { AsyncUnzipInflate };\n/**\n * A ZIP archive decompression stream that emits files as they are discovered\n */\nvar Unzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a ZIP decompression stream\n     * @param cb The callback to call whenever a file in the ZIP archive is found\n     */\n    function Unzip(cb) {\n        this.onfile = cb;\n        this.k = [];\n        this.o = {\n            0: UnzipPassThrough\n        };\n        this.p = et;\n    }\n    /**\n     * Pushes a chunk to be unzipped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzip.prototype.push = function (chunk, final) {\n        var _this = this;\n        if (!this.onfile)\n            err(5);\n        if (!this.p)\n            err(4);\n        if (this.c > 0) {\n            var len = Math.min(this.c, chunk.length);\n            var toAdd = chunk.subarray(0, len);\n            this.c -= len;\n            if (this.d)\n                this.d.push(toAdd, !this.c);\n            else\n                this.k[0].push(toAdd);\n            chunk = chunk.subarray(len);\n            if (chunk.length)\n                return this.push(chunk, final);\n        }\n        else {\n            var f = 0, i = 0, is = void 0, buf = void 0;\n            if (!this.p.length)\n                buf = chunk;\n            else if (!chunk.length)\n                buf = this.p;\n            else {\n                buf = new u8(this.p.length + chunk.length);\n                buf.set(this.p), buf.set(chunk, this.p.length);\n            }\n            var l = buf.length, oc = this.c, add = oc && this.d;\n            var _loop_2 = function () {\n                var _a;\n                var sig = b4(buf, i);\n                if (sig == 0x4034B50) {\n                    f = 1, is = i;\n                    this_1.d = null;\n                    this_1.c = 0;\n                    var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);\n                    if (l > i + 30 + fnl + es) {\n                        var chks_3 = [];\n                        this_1.k.unshift(chks_3);\n                        f = 2;\n                        var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);\n                        var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);\n                        if (sc_1 == 4294967295) {\n                            _a = dd ? [-2] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];\n                        }\n                        else if (dd)\n                            sc_1 = -1;\n                        i += es;\n                        this_1.c = sc_1;\n                        var d_1;\n                        var file_1 = {\n                            name: fn_1,\n                            compression: cmp_1,\n                            start: function () {\n                                if (!file_1.ondata)\n                                    err(5);\n                                if (!sc_1)\n                                    file_1.ondata(null, et, true);\n                                else {\n                                    var ctr = _this.o[cmp_1];\n                                    if (!ctr)\n                                        file_1.ondata(err(14, 'unknown compression type ' + cmp_1, 1), null, false);\n                                    d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);\n                                    d_1.ondata = function (err, dat, final) { file_1.ondata(err, dat, final); };\n                                    for (var _i = 0, chks_4 = chks_3; _i < chks_4.length; _i++) {\n                                        var dat = chks_4[_i];\n                                        d_1.push(dat, false);\n                                    }\n                                    if (_this.k[0] == chks_3 && _this.c)\n                                        _this.d = d_1;\n                                    else\n                                        d_1.push(et, true);\n                                }\n                            },\n                            terminate: function () {\n                                if (d_1 && d_1.terminate)\n                                    d_1.terminate();\n                            }\n                        };\n                        if (sc_1 >= 0)\n                            file_1.size = sc_1, file_1.originalSize = su_1;\n                        this_1.onfile(file_1);\n                    }\n                    return \"break\";\n                }\n                else if (oc) {\n                    if (sig == 0x8074B50) {\n                        is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                    else if (sig == 0x2014B50) {\n                        is = i -= 4, f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                }\n            };\n            var this_1 = this;\n            for (; i < l - 4; ++i) {\n                var state_1 = _loop_2();\n                if (state_1 === \"break\")\n                    break;\n            }\n            this.p = et;\n            if (oc < 0) {\n                var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);\n                if (add)\n                    add.push(dat, !!f);\n                else\n                    this.k[+(f == 2)].push(dat);\n            }\n            if (f & 2)\n                return this.push(buf.subarray(i), final);\n            this.p = buf.subarray(i);\n        }\n        if (final) {\n            if (this.c)\n                err(13);\n            this.p = null;\n        }\n    };\n    /**\n     * Registers a decoder with the stream, allowing for files compressed with\n     * the compression type provided to be expanded correctly\n     * @param decoder The decoder constructor\n     */\n    Unzip.prototype.register = function (decoder) {\n        this.o[decoder.compression] = decoder;\n    };\n    return Unzip;\n}());\nexport { Unzip };\nvar mt = typeof queueMicrotask == 'function' ? queueMicrotask : typeof setTimeout == 'function' ? setTimeout : function (fn) { fn(); };\nexport function unzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var files = {};\n    var cbd = function (a, b) {\n        mt(function () { cb(a, b); });\n    };\n    mt(function () { cbd = cb; });\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558) {\n            cbd(err(13, 0, 1), null);\n            return tAll;\n        }\n    }\n    ;\n    var lft = b2(data, e + 8);\n    if (lft) {\n        var c = lft;\n        var o = b4(data, e + 16);\n        var z = o == 4294967295 || c == 65535;\n        if (z) {\n            var ze = b4(data, e - 12);\n            z = b4(data, ze) == 0x6064B50;\n            if (z) {\n                c = lft = b4(data, ze + 32);\n                o = b4(data, ze + 48);\n            }\n        }\n        var fltr = opts && opts.filter;\n        var _loop_3 = function (i) {\n            var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n            o = no;\n            var cbl = function (e, d) {\n                if (e) {\n                    tAll();\n                    cbd(e, null);\n                }\n                else {\n                    if (d)\n                        files[fn] = d;\n                    if (!--lft)\n                        cbd(null, files);\n                }\n            };\n            if (!fltr || fltr({\n                name: fn,\n                size: sc,\n                originalSize: su,\n                compression: c_1\n            })) {\n                if (!c_1)\n                    cbl(null, slc(data, b, b + sc));\n                else if (c_1 == 8) {\n                    var infl = data.subarray(b, b + sc);\n                    // Synchronously decompress under 512KB, or barely-compressed data\n                    if (su < 524288 || sc > 0.8 * su) {\n                        try {\n                            cbl(null, inflateSync(infl, { out: new u8(su) }));\n                        }\n                        catch (e) {\n                            cbl(e, null);\n                        }\n                    }\n                    else\n                        term.push(inflate(infl, { size: su }, cbl));\n                }\n                else\n                    cbl(err(14, 'unknown compression type ' + c_1, 1), null);\n            }\n            else\n                cbl(null, null);\n        };\n        for (var i = 0; i < c; ++i) {\n            _loop_3(i);\n        }\n    }\n    else\n        cbd(null, {});\n    return tAll;\n}\n/**\n * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better\n * performance with more than one file.\n * @param data The raw compressed ZIP file\n * @param opts The ZIP extraction options\n * @returns The decompressed files\n */\nexport function unzipSync(data, opts) {\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558)\n            err(13);\n    }\n    ;\n    var c = b2(data, e + 8);\n    if (!c)\n        return {};\n    var o = b4(data, e + 16);\n    var z = o == 4294967295 || c == 65535;\n    if (z) {\n        var ze = b4(data, e - 12);\n        z = b4(data, ze) == 0x6064B50;\n        if (z) {\n            c = b4(data, ze + 32);\n            o = b4(data, ze + 48);\n        }\n    }\n    var fltr = opts && opts.filter;\n    for (var i = 0; i < c; ++i) {\n        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        if (!fltr || fltr({\n            name: fn,\n            size: sc,\n            originalSize: su,\n            compression: c_2\n        })) {\n            if (!c_2)\n                files[fn] = slc(data, b, b + sc);\n            else if (c_2 == 8)\n                files[fn] = inflateSync(data.subarray(b, b + sc), { out: new u8(su) });\n            else\n                err(14, 'unknown compression type ' + c_2);\n        }\n    }\n    return files;\n}\n","import { resolve as resolve$1, basename as basename$1, extname as extname$1, dirname as dirname$1, isAbsolute, join } from 'path-browserify';\nimport { EventEmitter } from 'events';\nimport sax from 'sax';\n\nfunction resolve(...args) {\n  return resolve$1(...args) ;\n}\nfunction basename(p, ext) {\n  return basename$1(p, ext) ;\n}\nfunction extname(p) {\n  return extname$1(p) ;\n}\nfunction dirname(p) {\n  return dirname$1(p) ;\n}\nfunction isAbsolutePosix(p) {\n  return isAbsolute(p) ;\n}\nfunction joinPosix(...paths) {\n  return join(...paths) ;\n}\nvar path = {\n  resolve,\n  basename,\n  extname,\n  dirname,\n  isAbsolutePosix,\n  joinPosix\n};\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nfunction stripBOM(str) {\n  if (str.charCodeAt(0) === 65279) {\n    return str.slice(1);\n  }\n  return str;\n}\nconst defaults = {\n  0.1: {\n    explicitCharkey: false,\n    trim: true,\n    // normalize implicates trimming, just so you know\n    normalize: true,\n    // normalize tag names to lower case\n    normalizeTags: false,\n    // set default attribute object key\n    attrkey: \"@\",\n    // set default char object key\n    charkey: \"#\",\n    // always put child nodes in an array\n    explicitArray: false,\n    // ignore all attributes regardless\n    ignoreAttrs: false,\n    // merge attributes and child elements onto parent object.  this may cause collisions.\n    mergeAttrs: false,\n    explicitRoot: false,\n    validator: null,\n    xmlns: false,\n    // fold children elements into dedicated property (works only in 0.2)\n    explicitChildren: false,\n    childkey: \"@@\",\n    charsAsChildren: false,\n    // include white-space only text nodes\n    includeWhiteChars: false,\n    // callbacks are async? not in 0.1 mode\n    async: false,\n    strict: true,\n    attrNameProcessors: null,\n    attrValueProcessors: null,\n    tagNameProcessors: null,\n    valueProcessors: null,\n    emptyTag: \"\"\n  },\n  0.2: {\n    explicitCharkey: false,\n    trim: false,\n    normalize: false,\n    normalizeTags: false,\n    attrkey: \"$\",\n    charkey: \"_\",\n    explicitArray: true,\n    ignoreAttrs: false,\n    mergeAttrs: false,\n    explicitRoot: true,\n    validator: null,\n    xmlns: false,\n    explicitChildren: false,\n    preserveChildrenOrder: false,\n    childkey: \"$$\",\n    charsAsChildren: false,\n    // include white-space only text nodes\n    includeWhiteChars: false,\n    // not async in 0.2 mode either\n    async: false,\n    strict: true,\n    attrNameProcessors: null,\n    attrValueProcessors: null,\n    tagNameProcessors: null,\n    valueProcessors: null,\n    // xml building options\n    rootName: \"root\",\n    xmldec: { version: \"1.0\", encoding: \"UTF-8\", standalone: true },\n    doctype: null,\n    renderOpts: { pretty: true, indent: \"  \", newline: \"\\n\" },\n    headless: false,\n    chunkSize: 1e4,\n    emptyTag: \"\",\n    cdata: false\n  }\n};\nfunction normalize(str) {\n  return str.toLowerCase();\n}\nfunction isEmpty(thing) {\n  return typeof thing === \"object\" && thing !== null && Object.keys(thing).length === 0;\n}\nfunction processItem(processors, item, key) {\n  for (const process of processors) {\n    item = process(item, key);\n  }\n  return item;\n}\nfunction defineProperty(obj, key, value) {\n  const descriptor = /* @__PURE__ */ Object.create(null);\n  descriptor.value = value;\n  descriptor.writable = true;\n  descriptor.enumerable = true;\n  descriptor.configurable = true;\n  Object.defineProperty(obj, key, descriptor);\n}\nclass Parser extends EventEmitter {\n  constructor(opts) {\n    super();\n    __publicField(this, \"options\");\n    __publicField(this, \"remaining\", \"\");\n    __publicField(this, \"saxParser\");\n    __publicField(this, \"resultObject\", null);\n    __publicField(this, \"EXPLICIT_CHARKEY\");\n    // saxParser status\n    __publicField(this, \"errThrown\", false);\n    __publicField(this, \"ended\", false);\n    __publicField(this, \"processAsync\", () => {\n      try {\n        if (this.remaining.length <= this.options.chunkSize) {\n          const chunk = this.remaining;\n          this.remaining = \"\";\n          this.saxParser = this.saxParser.write(chunk);\n          this.saxParser.close();\n        } else {\n          const chunk = this.remaining.slice(0, this.options.chunkSize);\n          this.remaining = this.remaining.slice(this.options.chunkSize);\n          this.saxParser = this.saxParser.write(chunk);\n          setTimeout(this.processAsync, 0);\n        }\n      } catch (err) {\n        if (!this.errThrown) {\n          this.errThrown = true;\n          this.emit(\"error\", err);\n        }\n      }\n    });\n    __publicField(this, \"assignOrPush\", (obj, key, newValue) => {\n      if (!(key in obj)) {\n        if (!this.options.explicitArray) {\n          defineProperty(obj, key, newValue);\n        } else {\n          defineProperty(obj, key, [newValue]);\n        }\n      } else {\n        if (!Array.isArray(obj[key])) {\n          defineProperty(obj, key, [obj[key]]);\n        }\n        obj[key].push(newValue);\n      }\n    });\n    __publicField(this, \"reset\", () => {\n      this.removeAllListeners();\n      this.saxParser = sax.parser(this.options.strict, {\n        trim: false,\n        normalize: false,\n        xmlns: this.options.xmlns\n      });\n      this.errThrown = false;\n      this.saxParser.onerror = (error) => {\n        this.saxParser.resume();\n        if (!this.errThrown) {\n          this.errThrown = true;\n          this.emit(\"error\", error);\n        }\n      };\n      this.saxParser.onend = () => {\n        if (!this.ended) {\n          this.ended = true;\n          this.emit(\"end\", this.resultObject);\n        }\n      };\n      this.ended = false;\n      this.EXPLICIT_CHARKEY = this.options.explicitCharkey;\n      this.resultObject = null;\n      const stack = [];\n      const attrkey = this.options.attrkey;\n      const charkey = this.options.charkey;\n      this.saxParser.onopentag = (node) => {\n        const obj = {};\n        obj[charkey] = \"\";\n        if (!this.options.ignoreAttrs) {\n          Object.keys(node.attributes).forEach((key) => {\n            if (!(attrkey in obj) && !this.options.mergeAttrs) {\n              obj[attrkey] = {};\n            }\n            const newValue = this.options.attrValueProcessors ? processItem(this.options.attrValueProcessors, node.attributes[key], key) : node.attributes[key];\n            const processedKey = this.options.attrNameProcessors ? processItem(this.options.attrNameProcessors, key) : key;\n            if (this.options.mergeAttrs) {\n              this.assignOrPush(obj, processedKey, newValue);\n            } else {\n              defineProperty(obj[attrkey], processedKey, newValue);\n            }\n          });\n        }\n        obj[\"#name\"] = this.options.tagNameProcessors ? processItem(this.options.tagNameProcessors, node.name) : node.name;\n        if (this.options.xmlns) {\n          obj[this.options.xmlnskey] = { uri: node.uri, local: node.local };\n        }\n        stack.push(obj);\n      };\n      this.saxParser.onclosetag = () => {\n        let obj = stack.pop();\n        const nodeName = obj[\"#name\"];\n        if (!this.options.explicitChildren || !this.options.preserveChildrenOrder) {\n          delete obj[\"#name\"];\n        }\n        let cdata;\n        if (obj.cdata === true) {\n          cdata = obj.cdata;\n          delete obj.cdata;\n        }\n        const s = stack[stack.length - 1];\n        let emptyStr = \"\";\n        if (obj[charkey].match(/^\\s*$/) && !cdata) {\n          emptyStr = obj[charkey];\n          delete obj[charkey];\n        } else {\n          if (this.options.trim) {\n            obj[charkey] = obj[charkey].trim();\n          }\n          if (this.options.normalize) {\n            obj[charkey] = obj[charkey].replace(/\\s{2,}/g, \" \").trim();\n          }\n          obj[charkey] = this.options.valueProcessors ? processItem(this.options.valueProcessors, obj[charkey], nodeName) : obj[charkey];\n          if (Object.keys(obj).length === 1 && charkey in obj && !this.EXPLICIT_CHARKEY) {\n            obj = obj[charkey];\n          }\n        }\n        if (isEmpty(obj)) {\n          if (typeof this.options.emptyTag === \"function\") {\n            obj = this.options.emptyTag();\n          } else {\n            obj = this.options.emptyTag !== \"\" ? this.options.emptyTag : emptyStr;\n          }\n        }\n        if (this.options.validator) {\n          const xpath = `/${stack.map((node) => node[\"#name\"]).concat(nodeName).join(\"/\")}`;\n          (() => {\n            try {\n              obj = this.options.validator(xpath, s && s[nodeName], obj);\n            } catch (err) {\n              this.emit(\"error\", err);\n            }\n          })();\n        }\n        if (this.options.explicitChildren && !this.options.mergeAttrs && typeof obj === \"object\") {\n          if (!this.options.preserveChildrenOrder) {\n            const node = {};\n            if (this.options.attrkey in obj) {\n              node[this.options.attrkey] = obj[this.options.attrkey];\n              delete obj[this.options.attrkey];\n            }\n            if (!this.options.charsAsChildren && this.options.charkey in obj) {\n              node[this.options.charkey] = obj[this.options.charkey];\n              delete obj[this.options.charkey];\n            }\n            if (Object.getOwnPropertyNames(obj).length > 0) {\n              node[this.options.childkey] = obj;\n            }\n            obj = node;\n          } else if (s) {\n            s[this.options.childkey] = s[this.options.childkey] || [];\n            const objClone = {};\n            Object.keys(obj).forEach((key) => {\n              defineProperty(objClone, key, obj[key]);\n            });\n            s[this.options.childkey].push(objClone);\n            delete obj[\"#name\"];\n            if (Object.keys(obj).length === 1 && charkey in obj && !this.EXPLICIT_CHARKEY) {\n              obj = obj[charkey];\n            }\n          }\n        }\n        if (stack.length > 0) {\n          this.assignOrPush(s, nodeName, obj);\n        } else {\n          if (this.options.explicitRoot) {\n            const old = obj;\n            const newObj = {};\n            defineProperty(newObj, nodeName, old);\n            obj = newObj;\n          }\n          this.resultObject = obj;\n          this.ended = true;\n          this.emit(\"end\", this.resultObject);\n        }\n      };\n      const ontext = (text) => {\n        const s = stack[stack.length - 1];\n        if (s) {\n          s[charkey] += text;\n          if (this.options.explicitChildren && this.options.preserveChildrenOrder && this.options.charsAsChildren && (this.options.includeWhiteChars || text.replace(/\\\\n/g, \"\").trim() !== \"\")) {\n            s[this.options.childkey] = s[this.options.childkey] || [];\n            const charChild = {\n              \"#name\": \"__text__\"\n            };\n            charChild[charkey] = text;\n            if (this.options.normalize) {\n              charChild[charkey] = charChild[charkey].replace(/\\s{2,}/g, \" \").trim();\n            }\n            s[this.options.childkey].push(charChild);\n          }\n        }\n        return s;\n      };\n      this.saxParser.ontext = ontext;\n      this.saxParser.oncdata = (text) => {\n        const s = ontext(text);\n        if (s) {\n          s.cdata = true;\n        }\n      };\n    });\n    __publicField(this, \"parseString\", (str, cb) => {\n      if (cb && typeof cb === \"function\") {\n        this.on(\"end\", (result) => {\n          this.reset();\n          cb(null, result);\n        });\n        this.on(\"error\", (err) => {\n          this.reset();\n          cb(err);\n        });\n      }\n      try {\n        str = str.toString();\n        if (str.trim() === \"\") {\n          this.emit(\"end\", null);\n          return true;\n        }\n        str = stripBOM(str);\n        if (this.options.async) {\n          this.remaining = str;\n          setTimeout(this.processAsync, 0);\n          return this.saxParser;\n        }\n        return this.saxParser.write(str).close();\n      } catch (err) {\n        if (!this.errThrown && !this.ended) {\n          this.emit(\"error\", err);\n          this.errThrown = true;\n        } else if (this.ended) {\n          throw err;\n        }\n      }\n    });\n    __publicField(this, \"parseStringPromise\", (str) => {\n      return new Promise((resolve, reject) => {\n        this.parseString(str, (err, value) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(value);\n          }\n        });\n      });\n    });\n    this.options = {};\n    Object.keys(defaults[\"0.2\"]).forEach((key) => {\n      this.options[key] = defaults[\"0.2\"][key];\n    });\n    if (opts) {\n      Object.keys(opts).forEach((key) => {\n        this.options[key] = opts[key];\n      });\n    }\n    if (this.options.xmlns) {\n      this.options.xmlnskey = `${this.options.attrkey}ns`;\n    }\n    if (this.options.normalizeTags) {\n      if (!this.options.tagNameProcessors) {\n        this.options.tagNameProcessors = [];\n      }\n      this.options.tagNameProcessors.unshift(normalize);\n    }\n    this.reset();\n  }\n}\nfunction parseStringPromise(str, a) {\n  let options = {};\n  if (typeof a === \"object\") {\n    options = a;\n  }\n  const parser = new Parser(options);\n  return parser.parseStringPromise(str);\n}\n\nasync function parsexml(str, optionsParserOptions = {}) {\n  const result = await parseStringPromise(str, optionsParserOptions);\n  return result;\n}\nfunction camelCase(str) {\n  return str.replace(/-([a-z])/gi, (g) => g[1].toUpperCase());\n}\n\nexport { camelCase, parsexml, path };\n","import { unzlibSync } from 'fflate';\nimport { parsexml } from '@lingo-reader/shared';\n\nconst htmlEntityMap = {\n  \"&lt;\": \"<\",\n  \"&gt;\": \">\",\n  \"&amp;\": \"&\",\n  \"&quot;\": '\"',\n  \"&#39;\": \"'\"\n};\nfunction unescapeHTML(str) {\n  if (!str.includes(\"&\")) {\n    return str;\n  }\n  return str.replace(/&(#x[\\dA-Fa-f]+|#\\d+|[a-zA-Z]+);/g, (match, entity) => {\n    if (entity.startsWith(\"#x\")) {\n      return String.fromCodePoint(Number.parseInt(entity.slice(2), 16));\n    } else if (entity.startsWith(\"#\")) {\n      return String.fromCodePoint(Number.parseInt(entity.slice(1), 10));\n    } else {\n      return htmlEntityMap[match] || match;\n    }\n  });\n}\nconst MIME = {\n  XML: \"application/xml\",\n  XHTML: \"application/xhtml+xml\",\n  HTML: \"text/html\",\n  CSS: \"text/css\",\n  SVG: \"image/svg+xml\"\n};\nconst fileSignatures = {\n  \"ffd8ff\": \"image/jpeg\",\n  \"89504e47\": \"image/png\",\n  \"47494638\": \"image/gif\",\n  \"424d\": \"image/bmp\",\n  \"3c737667\": \"image/svg+xml\",\n  \"00000018\": \"video/mp4\",\n  \"00000020\": \"video/mp4\",\n  \"1a45dfa3\": \"video/mkv\",\n  \"1f43b675\": \"video/webm\",\n  \"494433\": \"audio/mp3\",\n  \"52494646\": \"audio/wav\",\n  \"4f676753\": \"audio/ogg\",\n  \"00010000\": \"font/ttf\",\n  \"74727565\": \"font/ttf\",\n  \"4f54544f\": \"font/otf\",\n  \"774f4646\": \"font/woff\",\n  \"774f4632\": \"font/woff2\",\n  \"504c\": \"font/eot\"\n};\nfunction getFileMimeType(fileBuffer) {\n  const header = fileBuffer.slice(0, 12);\n  const hexHeader = Array.from(header).map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n  for (const [signature, type] of Object.entries(fileSignatures)) {\n    if (hexHeader.startsWith(signature)) {\n      return type;\n    }\n  }\n  return \"unknown\";\n}\nfunction saveResource(data, type, filename, imageSaveDir) {\n  {\n    return URL.createObjectURL(new Blob([data], { type }));\n  }\n}\nconst mobiEncoding = {\n  1252: \"windows-1252\",\n  65001: \"utf-8\"\n};\nconst mobiLang = {\n  1: [\"ar\", \"ar-SA\", \"ar-IQ\", \"ar-EG\", \"ar-LY\", \"ar-DZ\", \"ar-MA\", \"ar-TN\", \"ar-OM\", \"ar-YE\", \"ar-SY\", \"ar-JO\", \"ar-LB\", \"ar-KW\", \"ar-AE\", \"ar-BH\", \"ar-QA\"],\n  2: [\"bg\"],\n  3: [\"ca\"],\n  4: [\"zh\", \"zh-TW\", \"zh-CN\", \"zh-HK\", \"zh-SG\"],\n  5: [\"cs\"],\n  6: [\"da\"],\n  7: [\"de\", \"de-DE\", \"de-CH\", \"de-AT\", \"de-LU\", \"de-LI\"],\n  8: [\"el\"],\n  9: [\"en\", \"en-US\", \"en-GB\", \"en-AU\", \"en-CA\", \"en-NZ\", \"en-IE\", \"en-ZA\", \"en-JM\", null, \"en-BZ\", \"en-TT\", \"en-ZW\", \"en-PH\"],\n  10: [\"es\", \"es-ES\", \"es-MX\", null, \"es-GT\", \"es-CR\", \"es-PA\", \"es-DO\", \"es-VE\", \"es-CO\", \"es-PE\", \"es-AR\", \"es-EC\", \"es-CL\", \"es-UY\", \"es-PY\", \"es-BO\", \"es-SV\", \"es-HN\", \"es-NI\", \"es-PR\"],\n  11: [\"fi\"],\n  12: [\"fr\", \"fr-FR\", \"fr-BE\", \"fr-CA\", \"fr-CH\", \"fr-LU\", \"fr-MC\"],\n  13: [\"he\"],\n  14: [\"hu\"],\n  15: [\"is\"],\n  16: [\"it\", \"it-IT\", \"it-CH\"],\n  17: [\"ja\"],\n  18: [\"ko\"],\n  19: [\"nl\", \"nl-NL\", \"nl-BE\"],\n  20: [\"no\", \"nb\", \"nn\"],\n  21: [\"pl\"],\n  22: [\"pt\", \"pt-BR\", \"pt-PT\"],\n  23: [\"rm\"],\n  24: [\"ro\"],\n  25: [\"ru\"],\n  26: [\"hr\", null, \"sr\"],\n  27: [\"sk\"],\n  28: [\"sq\"],\n  29: [\"sv\", \"sv-SE\", \"sv-FI\"],\n  30: [\"th\"],\n  31: [\"tr\"],\n  32: [\"ur\"],\n  33: [\"id\"],\n  34: [\"uk\"],\n  35: [\"be\"],\n  36: [\"sl\"],\n  37: [\"et\"],\n  38: [\"lv\"],\n  39: [\"lt\"],\n  41: [\"fa\"],\n  42: [\"vi\"],\n  43: [\"hy\"],\n  44: [\"az\"],\n  45: [\"eu\"],\n  46: [\"hsb\"],\n  47: [\"mk\"],\n  48: [\"st\"],\n  49: [\"ts\"],\n  50: [\"tn\"],\n  52: [\"xh\"],\n  53: [\"zu\"],\n  54: [\"af\"],\n  55: [\"ka\"],\n  56: [\"fo\"],\n  57: [\"hi\"],\n  58: [\"mt\"],\n  59: [\"se\"],\n  62: [\"ms\"],\n  63: [\"kk\"],\n  65: [\"sw\"],\n  67: [\"uz\", null, \"uz-UZ\"],\n  68: [\"tt\"],\n  69: [\"bn\"],\n  70: [\"pa\"],\n  71: [\"gu\"],\n  72: [\"or\"],\n  73: [\"ta\"],\n  74: [\"te\"],\n  75: [\"kn\"],\n  76: [\"ml\"],\n  77: [\"as\"],\n  78: [\"mr\"],\n  79: [\"sa\"],\n  82: [\"cy\", \"cy-GB\"],\n  83: [\"gl\", \"gl-ES\"],\n  87: [\"kok\"],\n  97: [\"ne\"],\n  98: [\"fy\"]\n};\n\nconst pdbHeader = {\n  name: [0, 32, \"string\"],\n  type: [60, 4, \"string\"],\n  creator: [64, 4, \"string\"],\n  numRecords: [76, 2, \"uint\"]\n};\nconst palmdocHeader = {\n  compression: [0, 2, \"uint\"],\n  numTextRecords: [8, 2, \"uint\"],\n  recordSize: [10, 2, \"uint\"],\n  encryption: [12, 2, \"uint\"]\n};\nconst mobiHeader = {\n  magic: [16, 4, \"string\"],\n  length: [20, 4, \"uint\"],\n  type: [24, 4, \"uint\"],\n  encoding: [28, 4, \"uint\"],\n  uid: [32, 4, \"uint\"],\n  version: [36, 4, \"uint\"],\n  titleOffset: [84, 4, \"uint\"],\n  titleLength: [88, 4, \"uint\"],\n  localeRegion: [94, 1, \"uint\"],\n  localeLanguage: [95, 1, \"uint\"],\n  resourceStart: [108, 4, \"uint\"],\n  huffcdic: [112, 4, \"uint\"],\n  numHuffcdic: [116, 4, \"uint\"],\n  exthFlag: [128, 4, \"uint\"],\n  trailingFlags: [240, 4, \"uint\"],\n  indx: [244, 4, \"uint\"]\n};\nconst kf8Header = {\n  resourceStart: [108, 4, \"uint\"],\n  fdst: [192, 4, \"uint\"],\n  numFdst: [196, 4, \"uint\"],\n  frag: [248, 4, \"uint\"],\n  skel: [252, 4, \"uint\"],\n  guide: [260, 4, \"uint\"]\n};\nconst exthHeader = {\n  magic: [0, 4, \"string\"],\n  length: [4, 4, \"uint\"],\n  count: [8, 4, \"uint\"]\n};\nconst indxHeader = {\n  magic: [0, 4, \"string\"],\n  length: [4, 4, \"uint\"],\n  type: [8, 4, \"uint\"],\n  idxt: [20, 4, \"uint\"],\n  numRecords: [24, 4, \"uint\"],\n  encoding: [28, 4, \"uint\"],\n  language: [32, 4, \"uint\"],\n  total: [36, 4, \"uint\"],\n  ordt: [40, 4, \"uint\"],\n  ligt: [44, 4, \"uint\"],\n  numLigt: [48, 4, \"uint\"],\n  numCncx: [52, 4, \"uint\"]\n};\nconst tagxHeader = {\n  magic: [0, 4, \"string\"],\n  length: [4, 4, \"uint\"],\n  numControlBytes: [8, 4, \"uint\"]\n};\nconst huffHeader = {\n  magic: [0, 4, \"string\"],\n  offset1: [8, 4, \"uint\"],\n  offset2: [12, 4, \"uint\"]\n};\nconst cdicHeader = {\n  magic: [0, 4, \"string\"],\n  length: [4, 4, \"uint\"],\n  numEntries: [8, 4, \"uint\"],\n  codeLength: [12, 4, \"uint\"]\n};\nconst fdstHeader = {\n  magic: [0, 4, \"string\"],\n  numEntries: [8, 4, \"uint\"]\n};\nconst fontHeader = {\n  flags: [8, 4, \"uint\"],\n  dataStart: [12, 4, \"uint\"],\n  keyLength: [16, 4, \"uint\"],\n  keyStart: [20, 4, \"uint\"]\n};\n\nfunction getMobiFileName(file) {\n  let fileName = \"\";\n  {\n    fileName = file.name ?? \"\";\n  }\n  return fileName;\n}\nfunction bufferToArrayBuffer(buffer) {\n  return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);\n}\nasync function toArrayBuffer(file) {\n  {\n    return file instanceof Uint8Array ? bufferToArrayBuffer(file) : await file.arrayBuffer();\n  }\n}\nconst decoder = new TextDecoder();\nconst getString = (buffer) => decoder.decode(buffer);\nfunction getUint(buffer) {\n  const l = buffer.byteLength;\n  const func = l === 4 ? \"getUint32\" : l === 2 ? \"getUint16\" : \"getUint8\";\n  return new DataView(buffer)[func](0);\n}\nfunction getStruct(def, buffer) {\n  const res = {};\n  for (const key in def) {\n    const [start, len, type] = def[key];\n    res[key] = type === \"string\" ? getString(buffer.slice(start, start + len)) : getUint(buffer.slice(start, start + len));\n  }\n  return res;\n}\nfunction concatTypedArrays(arrays) {\n  const totalLength = arrays.reduce((sum, arr) => sum + arr.length, 0);\n  const result = new arrays[0].constructor(totalLength);\n  let offset = 0;\n  for (const array of arrays) {\n    result.set(array, offset);\n    offset += array.length;\n  }\n  return result;\n}\nconst getDecoder = (x) => new TextDecoder(mobiEncoding[x]);\nfunction getVarLen(byteArray, i = 0) {\n  let value = 0;\n  let length = 0;\n  for (const byte of byteArray.subarray(i, i + 4)) {\n    value = value << 7 | (byte & 127) >>> 0;\n    length++;\n    if (byte & 128) {\n      break;\n    }\n  }\n  return { value, length };\n}\nfunction getVarLenFromEnd(byteArray) {\n  let value = 0;\n  for (const byte of byteArray.subarray(-4)) {\n    if (byte & 128) {\n      value = 0;\n    }\n    value = value << 7 | byte & 127;\n  }\n  return value;\n}\nfunction countBitsSet(x) {\n  let count = 0;\n  for (; x > 0; x = x >> 1) {\n    if ((x & 1) === 1) {\n      count++;\n    }\n  }\n  return count;\n}\nfunction countUnsetEnd(x) {\n  let count = 0;\n  while ((x & 1) === 0) {\n    x = x >> 1;\n    count++;\n  }\n  return count;\n}\nfunction decompressPalmDOC(array) {\n  const output = [];\n  for (let i = 0; i < array.length; i++) {\n    const byte = array[i];\n    if (byte === 0) {\n      output.push(0);\n    } else if (byte <= 8) {\n      for (const x of array.subarray(i + 1, (i += byte) + 1))\n        output.push(x);\n    } else if (byte <= 127) {\n      output.push(byte);\n    } else if (byte <= 191) {\n      const bytes = byte << 8 | array[i++ + 1];\n      const distance = (bytes & 16383) >>> 3;\n      const length = (bytes & 7) + 3;\n      for (let j = 0; j < length; j++)\n        output.push(output[output.length - distance]);\n    } else {\n      output.push(32, byte ^ 128);\n    }\n  }\n  return Uint8Array.from(output);\n}\nfunction huffcdic(mobi, loadRecord) {\n  const huffRecord = loadRecord(mobi.huffcdic);\n  const { magic, offset1, offset2 } = getStruct(huffHeader, huffRecord);\n  if (magic !== \"HUFF\") {\n    throw new Error(\"Invalid HUFF record\");\n  }\n  const table1 = Array.from(\n    { length: 256 },\n    (_, i) => offset1 + i * 4\n  ).map((offset) => getUint(huffRecord.slice(offset, offset + 4))).map((x) => [x & 128, x & 31, x >>> 8]);\n  const table2 = [[0, 0], ...Array.from(\n    { length: 32 },\n    (_, i) => offset2 + i * 8\n  ).map((offset) => [\n    getUint(huffRecord.slice(offset, offset + 4)),\n    getUint(huffRecord.slice(offset + 4, offset + 8))\n  ])];\n  const dictionary = [];\n  for (let i = 1; i < mobi.numHuffcdic; i++) {\n    const record = loadRecord(mobi.huffcdic + i);\n    const cdic = getStruct(cdicHeader, record);\n    if (cdic.magic !== \"CDIC\") {\n      throw new Error(\"Invalid CDIC record\");\n    }\n    const n = Math.min(1 << cdic.codeLength, cdic.numEntries - dictionary.length);\n    const buffer = record.slice(cdic.length);\n    for (let i2 = 0; i2 < n; i2++) {\n      const offset = getUint(buffer.slice(i2 * 2, i2 * 2 + 2));\n      const x = getUint(buffer.slice(offset, offset + 2));\n      const length = x & 32767;\n      const decompressed = x & 32768;\n      const value = new Uint8Array(buffer.slice(offset + 2, offset + 2 + length));\n      dictionary.push([value, decompressed]);\n    }\n  }\n  const decompress = (byteArray) => {\n    let output = new Uint8Array();\n    const bitLength = byteArray.byteLength * 8;\n    for (let i = 0; i < bitLength; ) {\n      const bits = Number(read32Bits(byteArray, i));\n      let [found, codeLength, value] = table1[bits >>> 24];\n      if (!found) {\n        while (bits >>> 32 - codeLength < table2[codeLength][0])\n          codeLength += 1;\n        value = table2[codeLength][1];\n      }\n      i += codeLength;\n      if (i > bitLength) {\n        break;\n      }\n      const code = value - (bits >>> 32 - codeLength);\n      let [result, decompressed] = dictionary[code];\n      if (!decompressed) {\n        result = decompress(result);\n        dictionary[code] = [result, true];\n      }\n      output = concatTypedArrays([output, result]);\n    }\n    return output;\n  };\n  return decompress;\n}\nfunction read32Bits(byteArray, from) {\n  const startByte = from >> 3;\n  const end = from + 32;\n  const endByte = end >> 3;\n  let bits = 0n;\n  for (let i = startByte; i <= endByte; i++) {\n    bits = bits << 8n | BigInt(byteArray[i] ?? 0);\n  }\n  return bits >> 8n - BigInt(end & 7) & 0xFFFFFFFFn;\n}\nconst exthRecordType = {\n  100: [\"creator\", \"string\", true],\n  // many\n  101: [\"publisher\", \"string\", false],\n  103: [\"description\", \"string\", false],\n  104: [\"isbn\", \"string\", false],\n  105: [\"subject\", \"string\", true],\n  // many\n  106: [\"date\", \"string\", false],\n  108: [\"contributor\", \"string\", true],\n  // many\n  109: [\"rights\", \"string\", false],\n  110: [\"subjectCode\", \"string\", true],\n  // many\n  112: [\"source\", \"string\", true],\n  // many\n  113: [\"asin\", \"string\", false],\n  121: [\"boundary\", \"uint\", false],\n  122: [\"fixedLayout\", \"string\", false],\n  125: [\"numResources\", \"uint\", false],\n  126: [\"originalResolution\", \"string\", false],\n  127: [\"zeroGutter\", \"string\", false],\n  128: [\"zeroMargin\", \"string\", false],\n  129: [\"coverURI\", \"string\", false],\n  132: [\"regionMagnification\", \"string\", false],\n  201: [\"coverOffset\", \"uint\", false],\n  202: [\"thumbnailOffset\", \"uint\", false],\n  503: [\"title\", \"string\", false],\n  524: [\"language\", \"string\", true],\n  // many\n  527: [\"pageProgressionDirection\", \"string\", false]\n};\nfunction getExth(buf, encoding) {\n  const { magic, count } = getStruct(exthHeader, buf);\n  if (magic !== \"EXTH\") {\n    throw new Error(\"Invalid EXTH header\");\n  }\n  const decoder2 = getDecoder(encoding.toString());\n  const results = {};\n  let offset = 12;\n  for (let i = 0; i < count; i++) {\n    const type = getUint(buf.slice(offset, offset + 4));\n    const length = getUint(buf.slice(offset + 4, offset + 8));\n    if (type in exthRecordType) {\n      const [name, typ, ismany] = exthRecordType[type];\n      const data = buf.slice(offset + 8, offset + length);\n      const value = typ === \"uint\" ? getUint(data) : decoder2.decode(data);\n      if (ismany) {\n        results[name] ?? (results[name] = []);\n        results[name].push(value);\n      } else {\n        results[name] = value;\n      }\n    }\n    offset += length;\n  }\n  return results;\n}\nfunction getRemoveTrailingEntries(trailingFlags) {\n  const multibyte = trailingFlags & 1;\n  const numTrailingEntries = countBitsSet(trailingFlags >>> 1);\n  return (array) => {\n    for (let i = 0; i < numTrailingEntries; i++) {\n      const length = getVarLenFromEnd(array);\n      array = array.subarray(0, -length);\n    }\n    if (multibyte) {\n      const length = (array[array.length - 1] & 3) + 1;\n      array = array.subarray(0, -length);\n    }\n    return array;\n  };\n}\nfunction getFont(buf) {\n  const { flags, dataStart, keyLength, keyStart } = getStruct(fontHeader, buf);\n  const array = new Uint8Array(buf.slice(dataStart));\n  if (flags & 2) {\n    const bytes = keyLength === 16 ? 1024 : 1040;\n    const key = new Uint8Array(buf.slice(keyStart, keyStart + keyLength));\n    const length = Math.min(bytes, array.length);\n    for (let i = 0; i < length; i++) array[i] = array[i] ^ key[i % key.length];\n  }\n  if (flags & 1) {\n    try {\n      return unzlibSync(array);\n    } catch (e) {\n      console.warn(e);\n      console.warn(\"Failed to decompress font\");\n    }\n  }\n  return array;\n}\nfunction getIndexData(indxIndex, loadRecord) {\n  const indxRecord = loadRecord(indxIndex);\n  const indx = getStruct(indxHeader, indxRecord);\n  if (indx.magic !== \"INDX\")\n    throw new Error(\"Invalid INDX record\");\n  const decoder2 = getDecoder(indx.encoding.toString());\n  const cncx = {};\n  let cncxRecordOffset = 0;\n  for (let i = 0; i < indx.numCncx; i++) {\n    const record = loadRecord(indxIndex + indx.numRecords + i + 1);\n    const array = new Uint8Array(record);\n    for (let pos = 0; pos < array.byteLength; ) {\n      const index = pos;\n      const { value, length } = getVarLen(array, pos);\n      pos += length;\n      const result = record.slice(pos, pos + value);\n      pos += value;\n      cncx[cncxRecordOffset + index] = decoder2.decode(result);\n    }\n    cncxRecordOffset += 65536;\n  }\n  const tagxBuffer = indxRecord.slice(indx.length);\n  const tagx = getStruct(tagxHeader, tagxBuffer);\n  if (tagx.magic !== \"TAGX\")\n    throw new Error(\"Invalid TAGX section\");\n  const numTags = (tagx.length - 12) / 4;\n  const tagTable = Array.from(\n    { length: numTags },\n    (_, i) => new Uint8Array(tagxBuffer.slice(12 + i * 4, 12 + i * 4 + 4))\n  );\n  const table = [];\n  for (let i = 0; i < indx.numRecords; i++) {\n    const record = loadRecord(indxIndex + 1 + i);\n    const array = new Uint8Array(record);\n    const indx2 = getStruct(indxHeader, record);\n    if (indx2.magic !== \"INDX\") {\n      throw new Error(\"Invalid INDX record\");\n    }\n    for (let j = 0; j < indx2.numRecords; j++) {\n      const offsetOffset = indx2.idxt + 4 + 2 * j;\n      const offset = getUint(record.slice(offsetOffset, offsetOffset + 2));\n      const length = getUint(record.slice(offset, offset + 1));\n      const name = getString(record.slice(offset + 1, offset + 1 + length));\n      const tags = [];\n      const startPos = offset + 1 + length;\n      let controlByteIndex = 0;\n      let pos = startPos + tagx.numControlBytes;\n      for (const [tag, numValues, mask, end] of tagTable) {\n        if (end & 1) {\n          controlByteIndex++;\n          continue;\n        }\n        const offset2 = startPos + controlByteIndex;\n        const value = getUint(record.slice(offset2, offset2 + 1)) & mask;\n        if (value === mask) {\n          if (countBitsSet(mask) > 1) {\n            const { value: value2, length: length2 } = getVarLen(array, pos);\n            tags.push([tag, 0, value2, numValues]);\n            pos += length2;\n          } else {\n            tags.push([tag, 1, 0, numValues]);\n          }\n        } else {\n          tags.push([tag, value >> countUnsetEnd(mask), 0, numValues]);\n        }\n      }\n      const tagMap = {};\n      for (const [tag, valueCount, valueBytes, numValues] of tags) {\n        const values = [];\n        if (valueCount !== 0) {\n          for (let i2 = 0; i2 < valueCount * numValues; i2++) {\n            const { value, length: length2 } = getVarLen(array, pos);\n            values.push(value);\n            pos += length2;\n          }\n        } else {\n          let count = 0;\n          while (count < valueBytes) {\n            const { value, length: length2 } = getVarLen(array, pos);\n            values.push(value);\n            pos += length2;\n            count += length2;\n          }\n        }\n        tagMap[tag] = values;\n      }\n      table.push({ name, tagMap });\n    }\n  }\n  return { table, cncx };\n}\nfunction getNCX(indxIndex, loadRecord) {\n  const { table, cncx } = getIndexData(indxIndex, loadRecord);\n  const items = table.map(({ tagMap }, index) => ({\n    index,\n    offset: tagMap[1]?.[0],\n    size: tagMap[2]?.[0],\n    label: cncx[tagMap[3]?.[0]] ?? \"\",\n    headingLevel: tagMap[4]?.[0],\n    pos: tagMap[6],\n    parent: tagMap[21]?.[0],\n    firstChild: tagMap[22]?.[0],\n    lastChild: tagMap[23]?.[0]\n  }));\n  const getChildren = (item) => {\n    if (item.firstChild == null)\n      return item;\n    item.children = items.filter((x) => x.parent === item.index).map(getChildren);\n    return item;\n  };\n  return items.filter((item) => item.headingLevel === 0).map(getChildren);\n}\nconst mbpPagebreakRegex = /<\\s*(?:mbp:)?pagebreak[^>]*>/gi;\nfunction makePosURI(fid = 0, off = 0) {\n  return `kindle:pos:fid:${fid.toString(32).toUpperCase().padStart(4, \"0\")}:off:${off.toString(32).toUpperCase().padStart(10, \"0\")}`;\n}\nconst selectorReg = /\\s(id|name|aid)\\s*=\\s*['\"]([^'\"]*)['\"]/i;\nfunction getFragmentSelector(str) {\n  const match = str.match(selectorReg);\n  if (!match) {\n    return \"\";\n  }\n  const [, attr, value] = match;\n  return `[${attr}=\"${value}\"]`;\n}\nconst kindlePosRegex = /kindle:pos:fid:(\\w+):off:(\\w+)/;\nfunction parsePosURI(str) {\n  const [fid, off] = str.match(kindlePosRegex).slice(1);\n  return {\n    fid: Number.parseInt(fid, 32),\n    off: Number.parseInt(off, 32)\n  };\n}\nconst kindleResourceRegex = /kindle:(flow|embed):(\\w+)(?:\\?mime=(\\w+\\/[-+.\\w]+))?/;\n\nvar __defProp$2 = Object.defineProperty;\nvar __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$2 = (obj, key, value) => __defNormalProp$2(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nclass MobiFile {\n  constructor(file) {\n    __publicField$2(this, \"fileArrayBuffer\");\n    // extract from pdb header\n    __publicField$2(this, \"recordsOffset\");\n    __publicField$2(this, \"recordsMagic\");\n    // book start index in records\n    __publicField$2(this, \"start\", 0);\n    // extract from first record\n    __publicField$2(this, \"pdbHeader\");\n    __publicField$2(this, \"mobiHeader\");\n    __publicField$2(this, \"palmdocHeader\");\n    __publicField$2(this, \"kf8Header\");\n    __publicField$2(this, \"exth\");\n    __publicField$2(this, \"isKf8\", false);\n    // resource start index in records\n    __publicField$2(this, \"resourceStart\");\n    __publicField$2(this, \"decoder\");\n    __publicField$2(this, \"encoder\");\n    __publicField$2(this, \"removeTrailingEntries\");\n    __publicField$2(this, \"decompress\");\n    this.fileArrayBuffer = file;\n    this.parsePdbHeader();\n    this.parseFirstRecord(this.loadRecord(0));\n    this.resourceStart = this.mobiHeader.resourceStart;\n    if (!this.isKf8) {\n      const boundary = this.exth.boundary ?? 4294967295;\n      if (boundary < 4294967295) {\n        try {\n          this.parseFirstRecord(this.loadRecord(boundary));\n          this.resourceStart = this.kf8Header?.resourceStart ?? this.mobiHeader.resourceStart;\n          this.start = boundary;\n          this.isKf8 = true;\n        } catch (e) {\n        }\n      }\n    }\n    this.setup();\n  }\n  decode(arr) {\n    return this.decoder.decode(arr);\n  }\n  encode(str) {\n    return this.encoder.encode(str);\n  }\n  loadRecord(index) {\n    const [start, end] = this.recordsOffset[this.start + index];\n    return this.fileArrayBuffer.slice(start, end);\n  }\n  loadMagic(index) {\n    return this.recordsMagic[this.start + index];\n  }\n  loadTextBuffer(index) {\n    return this.decompress(\n      this.removeTrailingEntries(\n        new Uint8Array(\n          this.loadRecord(index + 1)\n        )\n      )\n    );\n  }\n  loadResource(index) {\n    const buf = this.loadRecord(this.resourceStart + index);\n    const magic = getString(buf.slice(0, 4));\n    let data;\n    if (magic === \"FONT\") {\n      data = getFont(buf);\n    } else if (magic === \"VIDE\" || magic === \"AUDI\") {\n      data = new Uint8Array(buf.slice(12));\n    } else {\n      data = new Uint8Array(buf);\n    }\n    return {\n      type: getFileMimeType(data),\n      raw: data\n    };\n  }\n  getNCX() {\n    const index = this.mobiHeader.indx;\n    if (index < 4294967295) {\n      return getNCX(index, this.loadRecord.bind(this));\n    }\n    return void 0;\n  }\n  getMetadata() {\n    const mobi = this.mobiHeader;\n    const exth = this.exth;\n    return {\n      identifier: this.mobiHeader.uid.toString(),\n      title: exth?.title || mobi.title,\n      author: exth?.creator?.map(unescapeHTML) ?? [],\n      publisher: exth?.publisher ?? \"\",\n      // language in exth is many, we use the first one in this case\n      language: exth?.language?.[0] ?? mobi.language,\n      published: exth?.date ?? \"\",\n      description: exth?.description ?? \"\",\n      subject: exth?.subject?.map(unescapeHTML) ?? [],\n      rights: exth?.rights ?? \"\",\n      contributor: exth?.contributor ?? []\n    };\n  }\n  getCoverImage() {\n    const exth = this.exth;\n    const coverOffset = Number(exth.coverOffset ?? 4294967295);\n    const thumbnailOffset = Number(exth.thumbnailOffset ?? 4294967295);\n    const offset = coverOffset < 4294967295 ? coverOffset : thumbnailOffset < 4294967295 ? thumbnailOffset : void 0;\n    if (offset) {\n      return this.loadResource(offset);\n    }\n    return void 0;\n  }\n  parsePdbHeader() {\n    const pdb = getStruct(pdbHeader, this.fileArrayBuffer.slice(0, 78));\n    pdb.name = pdb.name.replace(/\\0.*$/, \"\");\n    this.pdbHeader = pdb;\n    const recordsBuffer = this.fileArrayBuffer.slice(78, 78 + pdb.numRecords * 8);\n    const recordsStart = Array.from(\n      { length: pdb.numRecords },\n      (_, i) => getUint(recordsBuffer.slice(i * 8, i * 8 + 4))\n    );\n    this.recordsOffset = recordsStart.map(\n      (start, i) => [start, recordsStart[i + 1]]\n    );\n    this.recordsMagic = recordsStart.map(\n      (val) => getString(this.fileArrayBuffer.slice(val, val + 4))\n    );\n  }\n  // palmdocHeader, mobiHeader, isKf8, exth\n  parseFirstRecord(firstRecord) {\n    this.palmdocHeader = getStruct(palmdocHeader, firstRecord.slice(0, 16));\n    const mobi = getStruct(mobiHeader, firstRecord);\n    if (mobi.magic !== \"MOBI\") {\n      throw new Error(\"Missing MOBI header\");\n    }\n    const { titleOffset, titleLength, localeLanguage, localeRegion } = mobi;\n    const lang = mobiLang[localeLanguage.toString()] ?? [];\n    const mobiHeaderExtends = {\n      title: getString(firstRecord.slice(titleOffset, titleOffset + titleLength)),\n      language: lang[localeRegion >> 2] ?? lang[0] ?? \"unknown\"\n    };\n    this.mobiHeader = Object.assign(mobi, mobiHeaderExtends);\n    this.kf8Header = mobi.version >= 8 ? getStruct(kf8Header, firstRecord) : void 0;\n    this.isKf8 = mobi.version >= 8;\n    this.exth = mobi.exthFlag & 64 ? getExth(firstRecord.slice(mobi.length + 16), mobi.encoding) : void 0;\n  }\n  // setup decoder, encoder, decompress, removeTrailingEntries\n  setup() {\n    this.decoder = getDecoder(this.mobiHeader.encoding.toString());\n    this.encoder = new TextEncoder();\n    const compression = this.palmdocHeader.compression;\n    if (compression === 1) {\n      this.decompress = (f) => f;\n    } else if (compression === 2) {\n      this.decompress = decompressPalmDOC;\n    } else if (compression === 17480) {\n      this.decompress = huffcdic(this.mobiHeader, this.loadRecord.bind(this));\n    } else {\n      throw new Error(\"Unsupported compression\");\n    }\n    const trailingFlags = this.mobiHeader.trailingFlags;\n    this.removeTrailingEntries = getRemoveTrailingEntries(trailingFlags);\n  }\n}\n\nvar __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$1 = (obj, key, value) => __defNormalProp$1(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nasync function initKf8File(file, resourceSaveDir) {\n  const kf8 = new Kf8(file, resourceSaveDir);\n  await kf8.innerLoadFile();\n  await kf8.innerInit();\n  return kf8;\n}\nclass Kf8 {\n  constructor(file, resourceSaveDir = \"./images\") {\n    this.file = file;\n    __publicField$1(this, \"fileArrayBuffer\");\n    __publicField$1(this, \"mobiFile\");\n    __publicField$1(this, \"fileName\", \"\");\n    __publicField$1(this, \"fdstTable\", []);\n    __publicField$1(this, \"fullRawLength\", 0);\n    __publicField$1(this, \"skelTable\", []);\n    __publicField$1(this, \"fragTable\", []);\n    __publicField$1(this, \"chapters\", []);\n    __publicField$1(this, \"toc\", []);\n    __publicField$1(this, \"fragmentOffsets\", /* @__PURE__ */ new Map());\n    __publicField$1(this, \"fragmentSelectors\", /* @__PURE__ */ new Map());\n    __publicField$1(this, \"rawHead\", new Uint8Array());\n    __publicField$1(this, \"rawTail\", new Uint8Array());\n    __publicField$1(this, \"lastLoadedHead\", -1);\n    __publicField$1(this, \"lastLoadedTail\", -1);\n    __publicField$1(this, \"resourceCache\", /* @__PURE__ */ new Map());\n    __publicField$1(this, \"chapterCache\", /* @__PURE__ */ new Map());\n    __publicField$1(this, \"idToChapter\", /* @__PURE__ */ new Map());\n    __publicField$1(this, \"resourceSaveDir\", \"./images\");\n    this.fileName = getMobiFileName(file);\n    this.resourceSaveDir = resourceSaveDir;\n  }\n  getFileInfo() {\n    return {\n      fileName: this.fileName\n    };\n  }\n  getMetadata() {\n    return this.mobiFile.getMetadata();\n  }\n  getCoverImage() {\n    if (this.resourceCache.has(\"cover\")) {\n      return this.resourceCache.get(\"cover\");\n    }\n    const coverImage = this.mobiFile.getCoverImage();\n    let coverUrl = \"\";\n    if (coverImage) {\n      coverUrl = saveResource(coverImage.raw, coverImage.type, \"cover\", this.resourceSaveDir);\n      this.resourceCache.set(\"cover\", coverUrl);\n    }\n    return coverUrl;\n  }\n  getSpine() {\n    return this.chapters;\n  }\n  getToc() {\n    return this.toc;\n  }\n  async innerLoadFile() {\n    this.fileArrayBuffer = await toArrayBuffer(this.file);\n    this.mobiFile = new MobiFile(this.fileArrayBuffer);\n  }\n  async innerInit() {\n    const loadRecord = this.mobiFile.loadRecord.bind(this.mobiFile);\n    const kf8Header = this.mobiFile.kf8Header;\n    const fdstBuffer = this.mobiFile.loadRecord(kf8Header.fdst);\n    const fdst = getStruct(fdstHeader, fdstBuffer);\n    if (fdst.magic !== \"FDST\") {\n      throw new Error(\"Missing FDST record\");\n    }\n    const fdstTable = Array.from(\n      { length: fdst.numEntries },\n      (_, i) => 12 + i * 8\n    ).map((offset) => [\n      getUint(fdstBuffer.slice(offset, offset + 4)),\n      getUint(fdstBuffer.slice(offset + 4, offset + 8))\n    ]);\n    this.fdstTable = fdstTable;\n    this.fullRawLength = fdstTable[fdstTable.length - 1][1];\n    const skelData = getIndexData(kf8Header.skel, loadRecord);\n    const skelTable = skelData.table.map(({ name, tagMap }, index) => ({\n      index,\n      name,\n      numFrag: tagMap[1][0],\n      offset: tagMap[6][0],\n      length: tagMap[6][1]\n    }));\n    this.skelTable = skelTable;\n    const fragData = getIndexData(kf8Header.frag, loadRecord);\n    const fragTable = fragData.table.map(({ name, tagMap }) => ({\n      insertOffset: Number.parseInt(name),\n      selector: fragData.cncx[tagMap[2][0]],\n      index: tagMap[4][0],\n      offset: tagMap[6][0],\n      length: tagMap[6][1]\n    }));\n    this.fragTable = fragTable;\n    const chapters = this.skelTable.reduce((acc, skel, index) => {\n      const last = acc[acc.length - 1];\n      const fragStart = last?.fragEnd ?? 0;\n      const fragEnd = fragStart + skel.numFrag;\n      const frags = this.fragTable.slice(fragStart, fragEnd);\n      const length = skel.length + frags.reduce((a, v) => a + v.length, 0);\n      const totalLength = (last?.totalLength ?? 0) + length;\n      const chapter = { id: index.toString(), skel, frags, fragEnd, length, totalLength };\n      this.idToChapter.set(index, chapter);\n      acc.push(chapter);\n      return acc;\n    }, []);\n    this.chapters = chapters;\n    const ncx = this.mobiFile.getNCX();\n    if (ncx) {\n      const map = ({ label, pos, children }) => {\n        const [fid, off] = pos;\n        const href = makePosURI(fid, off);\n        const arr = this.fragmentOffsets.get(fid);\n        if (arr) {\n          arr.push(off);\n        } else {\n          this.fragmentOffsets.set(fid, [off]);\n        }\n        return { label, href, children: children?.map(map) };\n      };\n      this.toc = ncx.map(map);\n    }\n  }\n  getGuide() {\n    const index = this.mobiFile.kf8Header.guide;\n    if (index < 4294967295) {\n      const loadRecord = this.mobiFile.loadRecord.bind(this.mobiFile);\n      const { table, cncx } = getIndexData(index, loadRecord);\n      return table.map(({ name, tagMap }) => ({\n        label: cncx[tagMap[1][0]] ?? \"\",\n        type: name?.split(/\\s/),\n        href: makePosURI(tagMap[6]?.[0] ?? tagMap[3]?.[0])\n      }));\n    }\n    return void 0;\n  }\n  loadRaw(start, end) {\n    const distanceHead = end - this.rawHead.length;\n    const distanceEnd = this.fullRawLength === 0 ? Infinity : this.fullRawLength - this.rawTail.length - start;\n    if (distanceHead < 0 || distanceHead < distanceEnd) {\n      while (this.rawHead.length < end) {\n        this.lastLoadedHead++;\n        const index = this.lastLoadedHead;\n        const data = this.mobiFile.loadTextBuffer(index);\n        this.rawHead = concatTypedArrays([this.rawHead, data]);\n      }\n      return this.rawHead.slice(start, end);\n    }\n    while (this.fullRawLength - this.rawTail.length > start) {\n      this.lastLoadedTail++;\n      const index = this.mobiFile.palmdocHeader.numTextRecords - 1 - this.lastLoadedTail;\n      const data = this.mobiFile.loadTextBuffer(index);\n      this.rawTail = concatTypedArrays([data, this.rawTail]);\n    }\n    const rawTailStart = this.fullRawLength - this.rawTail.length;\n    return this.rawTail.slice(start - rawTailStart, end - rawTailStart);\n  }\n  loadText(chapter) {\n    const { skel, frags, length } = chapter;\n    const raw = this.loadRaw(skel.offset, skel.offset + length);\n    let skeleton = raw.slice(0, skel.length);\n    for (const frag of frags) {\n      const insertOffset = frag.insertOffset - skel.offset;\n      const offset = skel.length + frag.offset;\n      const fragRaw = raw.slice(offset, offset + frag.length);\n      skeleton = concatTypedArrays([\n        skeleton.slice(0, insertOffset),\n        fragRaw,\n        skeleton.slice(insertOffset)\n      ]);\n      const offsets = this.fragmentOffsets.get(frag.index);\n      if (offsets) {\n        for (const offset2 of offsets) {\n          const str = this.mobiFile.decode(fragRaw.buffer).slice(offset2);\n          const selector = getFragmentSelector(str);\n          if (selector) {\n            this.cacheFragmentSelector(frag.index, offset2, selector);\n          }\n        }\n      }\n    }\n    return this.mobiFile.decode(skeleton.buffer);\n  }\n  loadChapter(id) {\n    const numId = Number.parseInt(id);\n    if (Number.isNaN(numId)) {\n      return void 0;\n    }\n    if (this.chapterCache.has(numId)) {\n      return this.chapterCache.get(numId);\n    }\n    const chapter = this.idToChapter.get(numId);\n    if (chapter) {\n      const processed = this.replace(this.loadText(chapter));\n      this.chapterCache.set(numId, processed);\n      return processed;\n    }\n    return void 0;\n  }\n  cacheFragmentSelector(id, offset, selector) {\n    const map = this.fragmentSelectors.get(id);\n    if (map) {\n      map.set(offset, selector);\n    } else {\n      const map2 = /* @__PURE__ */ new Map();\n      this.fragmentSelectors.set(id, map2);\n      map2.set(offset, selector);\n    }\n  }\n  loadFlow(index) {\n    if (index < 4294967295) {\n      return this.loadRaw(this.fdstTable[index][0], this.fdstTable[index][1]);\n    }\n    return void 0;\n  }\n  resolveHref(href) {\n    if (/^(?!blob|kindle)\\w+:/i.test(href)) {\n      return void 0;\n    }\n    const { fid, off } = parsePosURI(href);\n    const chapter = this.chapters.find(\n      (chapter2) => chapter2.frags.some(\n        (frag2) => frag2.index === fid\n      )\n    );\n    if (!chapter) {\n      return void 0;\n    }\n    const id = chapter.id;\n    const savedSelector = this.fragmentSelectors.get(fid)?.get(off);\n    if (savedSelector) {\n      return { id, selector: savedSelector };\n    }\n    const { skel, frags } = chapter;\n    const frag = frags.find((frag2) => frag2.index === fid);\n    const offset = skel.offset + skel.length + frag.offset;\n    const fragRaw = this.loadRaw(offset, offset + frag.length);\n    const str = this.mobiFile.decode(fragRaw.buffer).slice(off);\n    const selector = getFragmentSelector(str);\n    this.cacheFragmentSelector(fid, off, selector);\n    return { id, selector };\n  }\n  replaceResources(str) {\n    return str.replace(\n      new RegExp(kindleResourceRegex, \"gi\"),\n      (matched, resourceType, id, type) => {\n        if (this.resourceCache.has(matched)) {\n          return this.resourceCache.get(matched);\n        }\n        const raw = resourceType === \"flow\" ? this.loadFlow(Number.parseInt(id)) : this.mobiFile.loadResource(Number.parseInt(id) - 1).raw;\n        let blobData = \"\";\n        if (type === MIME.CSS || type === MIME.SVG) {\n          const text = this.mobiFile.decode(raw?.buffer);\n          const textReplaced = this.replaceResources(text);\n          blobData = textReplaced;\n        } else {\n          blobData = raw;\n        }\n        const url = saveResource(blobData, type, id, this.resourceSaveDir);\n        this.resourceCache.set(matched, url);\n        return url;\n      }\n    );\n  }\n  replace(str) {\n    const cssUrls = [];\n    const head = str.match(/<head[^>]*>([\\s\\S]*)<\\/head>/i)[1];\n    const links = head.match(/<link[^>]*>/gi) ?? [];\n    for (const link of links) {\n      const linkHref = link.match(/href=\"([^\"]*)\"/i)[1];\n      const id = link.match(kindleResourceRegex)[2];\n      const href = this.replaceResources(linkHref);\n      cssUrls.push({\n        id,\n        href\n      });\n    }\n    const body = str.match(/<body[^>]*>([\\s\\S]*)<\\/body>/i)[1];\n    const bodyReplaced = this.replaceResources(body);\n    return {\n      html: bodyReplaced,\n      css: cssUrls\n    };\n  }\n  destroy() {\n    this.resourceCache.forEach((url) => {\n      {\n        URL.revokeObjectURL(url);\n      }\n    });\n  }\n}\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nasync function initMobiFile(file, resourceSaveDir) {\n  const mobi = new Mobi(file, resourceSaveDir);\n  await mobi.innerLoadFile();\n  await mobi.innerInit();\n  return mobi;\n}\nclass Mobi {\n  constructor(file, resourceSaveDir = \"./images\") {\n    this.file = file;\n    __publicField(this, \"fileArrayBuffer\");\n    __publicField(this, \"mobiFile\");\n    __publicField(this, \"fileName\", \"\");\n    // chapter\n    __publicField(this, \"chapters\", []);\n    __publicField(this, \"idToChapter\", /* @__PURE__ */ new Map());\n    __publicField(this, \"toc\", []);\n    __publicField(this, \"resourceSaveDir\", \"./images\");\n    __publicField(this, \"chapterCache\", /* @__PURE__ */ new Map());\n    __publicField(this, \"resourceCache\", /* @__PURE__ */ new Map());\n    // TODO: optimize the logic\n    __publicField(this, \"recindexReg\", /recindex=[\"']?(\\d+)[\"']?/);\n    __publicField(this, \"mediarecindexReg\", /mediarecindex=[\"']?(\\d+)[\"']?/);\n    __publicField(this, \"fileposReg\", /filepos=[\"']?(\\d+)[\"']?/);\n    this.fileName = getMobiFileName(file);\n    this.resourceSaveDir = resourceSaveDir;\n  }\n  getFileInfo() {\n    return {\n      fileName: this.fileName\n    };\n  }\n  getSpine() {\n    return this.chapters;\n  }\n  loadChapter(id) {\n    const numId = Number.parseInt(id);\n    if (Number.isNaN(numId)) {\n      return void 0;\n    }\n    if (this.chapterCache.has(numId)) {\n      return this.chapterCache.get(numId);\n    }\n    const chapter = this.idToChapter.get(numId);\n    if (!chapter) {\n      return void 0;\n    }\n    const processedChapter = this.replace(chapter.text);\n    this.chapterCache.set(numId, processedChapter);\n    return processedChapter;\n  }\n  getToc() {\n    return this.toc;\n  }\n  getCoverImage() {\n    if (this.resourceCache.has(\"cover\")) {\n      return this.resourceCache.get(\"cover\");\n    }\n    const coverImage = this.mobiFile.getCoverImage();\n    let coverUrl = \"\";\n    if (coverImage) {\n      coverUrl = saveResource(coverImage.raw, coverImage.type, \"cover\", this.resourceSaveDir);\n      this.resourceCache.set(\"cover\", coverUrl);\n    }\n    return coverUrl;\n  }\n  getMetadata() {\n    return this.mobiFile.getMetadata();\n  }\n  async innerLoadFile() {\n    this.fileArrayBuffer = await toArrayBuffer(this.file);\n    this.mobiFile = new MobiFile(this.fileArrayBuffer);\n  }\n  async innerInit() {\n    const { palmdocHeader } = this.mobiFile;\n    const buffers = [];\n    for (let i = 0; i < palmdocHeader.numTextRecords; i++) {\n      buffers.push(this.mobiFile.loadTextBuffer(i));\n    }\n    const array = concatTypedArrays(buffers);\n    const str = Array.from(\n      array,\n      (val) => String.fromCharCode(val)\n    ).join(\"\");\n    const chapters = [];\n    const idToChapter = /* @__PURE__ */ new Map();\n    let id = 0;\n    const matches = Array.from(str.matchAll(mbpPagebreakRegex));\n    matches.unshift({ index: 0, input: \"\", groups: void 0, 0: \"\" });\n    for (let i = 0; i < matches.length; i++) {\n      const match = matches[i];\n      const start = match.index;\n      const matched = match[0];\n      const end = matches[i + 1]?.index;\n      const section = str.slice(start + matched.length, end);\n      const buffer = Uint8Array.from(section, (c) => c.charCodeAt(0));\n      const text = this.mobiFile.decode(buffer.buffer);\n      const chapter = {\n        id: String(id),\n        text,\n        start,\n        end,\n        size: buffer.length\n      };\n      chapters.push(chapter);\n      idToChapter.set(id, chapter);\n      id++;\n    }\n    const lastChapterText = chapters[chapters.length - 1].text;\n    chapters[chapters.length - 1].text = lastChapterText.slice(0, lastChapterText.indexOf(\"</body>\"));\n    const firstChapterText = chapters[0].text;\n    const bodyOpenTagIndex = firstChapterText.indexOf(\"<body>\");\n    chapters[0].text = firstChapterText.slice(bodyOpenTagIndex + \"<body>\".length);\n    this.chapters = chapters;\n    this.idToChapter = idToChapter;\n    const referenceStr = firstChapterText.slice(0, bodyOpenTagIndex);\n    const tocChapterStr = this.findTocChapter(referenceStr);\n    if (tocChapterStr) {\n      const wrappedChapterStr = `<wrapper>${tocChapterStr.text.replace(/filepos=(\\d+)/gi, 'filepos=\"$1\"')}</wrapper>`;\n      const tocAst = await parsexml(wrappedChapterStr, {\n        preserveChildrenOrder: true,\n        explicitChildren: true,\n        childkey: \"children\"\n      });\n      const toc = [];\n      this.parseNavMap(tocAst.wrapper.children, toc);\n      this.toc = toc;\n    }\n  }\n  findTocChapter(referenceStr) {\n    const tocPosReg = /<reference.*\\/>/g;\n    const refs = referenceStr.match(tocPosReg);\n    const typeReg = /type=\"(.+?)\"/;\n    const fileposReg = /filepos=(.*)/;\n    if (refs) {\n      for (const ref of refs) {\n        const type = ref.match(typeReg)?.[1].trim();\n        const filepos = ref.match(fileposReg)?.[1].trim();\n        if (type === \"toc\" && filepos) {\n          const tocPos = Number.parseInt(filepos, 10);\n          const chapter = this.chapters.find((ch) => ch.end > tocPos);\n          return chapter;\n        }\n      }\n    }\n    return void 0;\n  }\n  parseNavMap(children, toc) {\n    for (const child of children) {\n      const childName = child[\"#name\"];\n      if (childName === \"p\" || childName === \"blockquote\") {\n        let subItem = {\n          label: \"\",\n          href: \"\"\n        };\n        if (child.a) {\n          const a = child.a[0];\n          const label = a._;\n          const filepos = Number(a.$.filepos);\n          subItem = {\n            label,\n            href: `filepos:${filepos}`\n          };\n          toc.push(subItem);\n        }\n        if (child.p || child.blockquote) {\n          subItem.children = [];\n          this.parseNavMap(child.children, subItem.children);\n        }\n      }\n    }\n  }\n  loadResource(index) {\n    if (this.resourceCache.has(String(index))) {\n      return this.resourceCache.get(String(index));\n    }\n    const { type, raw } = this.mobiFile.loadResource(index - 1);\n    const resourceUrl = saveResource(raw, type, String(index), this.resourceSaveDir);\n    this.resourceCache.set(String(index), resourceUrl);\n    return resourceUrl;\n  }\n  replace(html) {\n    html = html.replace(\n      /<img[^>]*>/g,\n      (matched) => {\n        const recindex = matched.match(this.recindexReg)[1];\n        const url = this.loadResource(Number.parseInt(recindex));\n        return matched.replace(this.recindexReg, `src=\"${url}\"`);\n      }\n    );\n    html = html.replace(\n      /<(video|audio)[^>]*>/g,\n      (matched) => {\n        const mediarecindex = matched.match(this.recindexReg)[1];\n        const mediaUrl = this.loadResource(Number.parseInt(mediarecindex));\n        matched = matched.replace(this.mediarecindexReg, `src=\"${mediaUrl}\"`);\n        const recindex = matched.match(this.recindexReg)?.[1];\n        if (recindex) {\n          const posterUrl = this.loadResource(Number.parseInt(recindex));\n          matched = matched.replace(this.recindexReg, `poster=\"${posterUrl}\"`);\n        }\n        return matched;\n      }\n    );\n    html = html.replace(\n      /<a[^>]*>/g,\n      (matched) => {\n        const fileposMatch = matched.match(this.fileposReg);\n        if (!fileposMatch) {\n          return matched;\n        }\n        const filepos = fileposMatch[1];\n        return matched.replace(this.fileposReg, `href=\"filepos:${filepos}\"`);\n      }\n    );\n    return {\n      html,\n      css: []\n    };\n  }\n  resolveHref(href) {\n    const hrefmatch = href.match(/filepos:(\\d+)/);\n    if (!hrefmatch) {\n      return void 0;\n    }\n    const filepos = hrefmatch[1];\n    const fileposNum = Number(filepos);\n    const chapter = this.chapters.find((ch) => ch.end > fileposNum);\n    if (chapter) {\n      return { id: chapter.id, selector: `[id=\"filepos:${filepos}\"]` };\n    }\n    return void 0;\n  }\n  destroy() {\n    this.resourceCache.forEach((url) => {\n      {\n        URL.revokeObjectURL(url);\n      }\n    });\n    this.resourceCache.clear();\n  }\n}\n\nexport { initKf8File, initMobiFile };\n"],"names":["sax","parser","strict","opt","SAXParser","SAXStream","createStream","MAX_BUFFER_LENGTH","Stream","buffers","this","i","l","length","clearBuffers","q","c","bufferCheckPosition","lowercase","lowercasetags","looseCase","tags","closed","closedRoot","sawRoot","tag","error","noscript","state","S","BEGIN","strictEntities","ENTITIES","Object","create","XML_ENTITIES","attribList","xmlns","ns","rootNS","undefined","unquotedAttributeValues","trackPosition","position","line","column","emit","EVENTS","o","F","prototype","keys","a","hasOwnProperty","push","end","write","chunk","toString","charAt","BEGIN_WHITESPACE","beginWhiteSpace","TEXT","starti","textNode","substring","isWhitespace","strictFail","TEXT_ENTITY","OPEN_WAKA","startTagPosition","SCRIPT","SCRIPT_ENDING","script","CLOSE_TAG","SGML_DECL","sgmlDecl","isMatch","nameStart","OPEN_TAG","tagName","PROC_INST","procInstName","procInstBody","pad","Array","join","COMMENT","comment","doctype","DOCTYPE_DTD","toUpperCase","CDATA","emitNode","cdata","DOCTYPE","isQuote","SGML_DECL_QUOTED","DOCTYPE_QUOTED","DOCTYPE_DTD_QUOTED","COMMENT_ENDING","COMMENT_ENDED","textopts","CDATA_ENDING","CDATA_ENDING_2","PROC_INST_ENDING","PROC_INST_BODY","name","body","nameBody","newTag","openTag","OPEN_TAG_SLASH","ATTRIB","closeTag","attribName","attribValue","ATTRIB_NAME","ATTRIB_VALUE","attrib","ATTRIB_NAME_SAW_WHITE","attributes","value","ATTRIB_VALUE_QUOTED","ATTRIB_VALUE_UNQUOTED","ATTRIB_VALUE_ENTITY_Q","ATTRIB_VALUE_CLOSED","isAttribEnd","ATTRIB_VALUE_ENTITY_U","CLOSE_TAG_SAW_WHITE","notMatch","returnState","buffer","parsedEntity","parseEntity","unparsedEntities","values","includes","entity","entityBody","entityStart","Error","maxAllowed","Math","max","maxActual","len","closeText","m","checkBufferLength","resume","close","flush","ex","streamWraps","filter","ev","apply","_parser","writable","readable","me","onend","onerror","er","_decoder","forEach","defineProperty","get","set","h","removeAllListeners","on","enumerable","configurable","constructor","data","Buffer","isBuffer","TextDecoder","decode","stream","remaining","handler","indexOf","args","arguments","splice","call","XML_NAMESPACE","XMLNS_NAMESPACE","xml","regex","test","stringFromCharCode","floor","fromCodePoint","s","STATE","COMMENT_STARTING","amp","gt","lt","quot","apos","AElig","Aacute","Acirc","Agrave","Aring","Atilde","Auml","Ccedil","ETH","Eacute","Ecirc","Egrave","Euml","Iacute","Icirc","Igrave","Iuml","Ntilde","Oacute","Ocirc","Ograve","Oslash","Otilde","Ouml","THORN","Uacute","Ucirc","Ugrave","Uuml","Yacute","aacute","acirc","aelig","agrave","aring","atilde","auml","ccedil","eacute","ecirc","egrave","eth","euml","iacute","icirc","igrave","iuml","ntilde","oacute","ocirc","ograve","oslash","otilde","ouml","szlig","thorn","uacute","ucirc","ugrave","uuml","yacute","yuml","copy","reg","nbsp","iexcl","cent","pound","curren","yen","brvbar","sect","uml","ordf","laquo","not","shy","macr","deg","plusmn","sup1","sup2","sup3","acute","micro","para","middot","cedil","ordm","raquo","frac14","frac12","frac34","iquest","times","divide","OElig","oelig","Scaron","scaron","Yuml","fnof","circ","tilde","Alpha","Beta","Gamma","Delta","Epsilon","Zeta","Eta","Theta","Iota","Kappa","Lambda","Mu","Nu","Xi","Omicron","Pi","Rho","Sigma","Tau","Upsilon","Phi","Chi","Psi","Omega","alpha","beta","gamma","delta","epsilon","zeta","eta","theta","iota","kappa","lambda","mu","nu","xi","omicron","pi","rho","sigmaf","sigma","tau","upsilon","phi","chi","psi","omega","thetasym","upsih","piv","ensp","emsp","thinsp","zwnj","zwj","lrm","rlm","ndash","mdash","lsquo","rsquo","sbquo","ldquo","rdquo","bdquo","dagger","Dagger","bull","hellip","permil","prime","Prime","lsaquo","rsaquo","oline","frasl","euro","image","weierp","real","trade","alefsym","larr","uarr","rarr","darr","harr","crarr","lArr","uArr","rArr","dArr","hArr","forall","part","exist","empty","nabla","isin","notin","ni","prod","sum","minus","lowast","radic","prop","infin","ang","and","or","cap","cup","int","there4","sim","cong","asymp","ne","equiv","le","ge","sub","sup","nsub","sube","supe","oplus","otimes","perp","sdot","lceil","rceil","lfloor","rfloor","lang","rang","loz","spades","clubs","hearts","diams","key","e","String","fromCharCode","event","nodeType","text","trim","normalize","replace","message","parent","qname","attribute","qualName","split","prefix","local","qn","selfClosing","uri","JSON","stringify","p","nv","isSelfClosing","toLowerCase","t","closeTo","pop","x","n","num","entityLC","numStr","slice","parseInt","isNaN","result","highSurrogate","lowSurrogate","codeUnits","index","codePoint","Number","isFinite","RangeError","exports","assertPath","path","TypeError","normalizeStringPosix","allowAboveRoot","code","res","lastSegmentLength","lastSlash","dots","charCodeAt","lastSlashIndex","lastIndexOf","posix","resolve","cwd","resolvedPath","resolvedAbsolute","process","isAbsolute","trailingSeparator","joined","arg","relative","from","to","fromStart","fromEnd","fromLen","toStart","toLen","lastCommonSep","fromCode","out","_makeLong","dirname","hasRoot","matchedSlash","basename","ext","start","extIdx","firstNonSlashEnd","extname","startDot","startPart","preDotState","format","pathObject","sep","dir","root","base","_format","parse","ret","delimiter","win32","module","u8","Uint8Array","u16","Uint16Array","i32","Int32Array","fleb","fdeb","clim","freb","eb","b","r","j","_a","fl","revfl","_b","fd","rev","hMap","cd","mb","co","rvb","sv","r_1","v","flt","fdt","bits","d","bits16","shft","slc","subarray","ec","err","ind","msg","nt","captureStackTrace","inflt","dat","st","buf","dict","sl","dl","f","noBuf","resize","noSt","cbuf","bl","nbuf","final","pos","bt","lm","dm","lbt","dbt","tbts","type","flrm","fdrm","hLit","hcLen","tl","ldt","clt","clb","clbmsk","clm","dt","lms","dms","lpos","sym","add","dsym","shift","dend","min","et","zls","unzlibSync","opts","dictionary","td","queueMicrotask","setTimeout","__defProp","__publicField","obj","__defNormalProp","defaults","explicitCharkey","normalizeTags","attrkey","charkey","explicitArray","ignoreAttrs","mergeAttrs","explicitRoot","validator","explicitChildren","childkey","charsAsChildren","includeWhiteChars","async","attrNameProcessors","attrValueProcessors","tagNameProcessors","valueProcessors","emptyTag","preserveChildrenOrder","rootName","xmldec","version","encoding","standalone","renderOpts","pretty","indent","newline","headless","chunkSize","str","processItem","processors","item","descriptor","Parser","EventEmitter","super","options","saxParser","processAsync","errThrown","newValue","isArray","ended","resultObject","EXPLICIT_CHARKEY","stack","onopentag","node","processedKey","assignOrPush","xmlnskey","onclosetag","nodeName","emptyStr","thing","match","xpath","map","concat","objClone","getOwnPropertyNames","newObj","ontext","charChild","oncdata","cb","reset","stripBOM","Promise","reject","parseString","unshift","parsexml","optionsParserOptions","parseStringPromise","htmlEntityMap","unescapeHTML","startsWith","fileSignatures","getFileMimeType","fileBuffer","header","hexHeader","padStart","signature","entries","saveResource","filename","imageSaveDir","URL","createObjectURL","Blob","mobiEncoding","mobiLang","pdbHeader","creator","numRecords","palmdocHeader","compression","numTextRecords","recordSize","encryption","mobiHeader","magic","uid","titleOffset","titleLength","localeRegion","localeLanguage","resourceStart","huffcdic","numHuffcdic","exthFlag","trailingFlags","indx","kf8Header","fdst","numFdst","frag","skel","guide","exthHeader","count","indxHeader","idxt","language","total","ordt","ligt","numLigt","numCncx","tagxHeader","numControlBytes","huffHeader","offset1","offset2","cdicHeader","numEntries","codeLength","fontHeader","flags","dataStart","keyLength","keyStart","getMobiFileName","file","fileName","toArrayBuffer","byteOffset","byteLength","arrayBuffer","decoder","getString","getUint","func","DataView","getStruct","def","concatTypedArrays","arrays","totalLength","reduce","arr","offset","array","getDecoder","getVarLen","byteArray","byte","getVarLenFromEnd","countBitsSet","countUnsetEnd","decompressPalmDOC","output","bytes","distance","read32Bits","endByte","BigInt","exthRecordType","getIndexData","indxIndex","loadRecord","indxRecord","decoder2","cncx","cncxRecordOffset","record","tagxBuffer","tagx","numTags","tagTable","_","table","indx2","offsetOffset","startPos","controlByteIndex","numValues","mask","value2","length2","tagMap","valueCount","valueBytes","i2","mbpPagebreakRegex","__defProp$2","__publicField$2","__defNormalProp$2","MobiFile","fileArrayBuffer","parsePdbHeader","parseFirstRecord","isKf8","boundary","exth","setup","encode","encoder","recordsOffset","loadMagic","recordsMagic","loadTextBuffer","decompress","removeTrailingEntries","loadResource","console","warn","getFont","raw","getNCX","items","size","label","headingLevel","firstChild","lastChild","getChildren","children","bind","getMetadata","mobi","identifier","title","author","publisher","published","date","description","subject","rights","contributor","getCoverImage","coverOffset","thumbnailOffset","pdb","recordsBuffer","recordsStart","val","firstRecord","mobiHeaderExtends","assign","results","typ","ismany","getExth","TextEncoder","huffRecord","table1","table2","cdic","decompressed","bitLength","found","multibyte","numTrailingEntries","getRemoveTrailingEntries","initMobiFile","resourceSaveDir","Mobi","innerLoadFile","innerInit","Map","getFileInfo","getSpine","chapters","loadChapter","id","numId","chapterCache","has","chapter","idToChapter","processedChapter","getToc","toc","resourceCache","coverImage","mobiFile","coverUrl","matches","matchAll","input","groups","matched","section","lastChapterText","firstChapterText","bodyOpenTagIndex","referenceStr","tocChapterStr","findTocChapter","wrappedChapterStr","tocAst","parseNavMap","wrapper","refs","typeReg","fileposReg","ref","filepos","tocPos","find","ch","child","childName","subItem","href","$","blockquote","resourceUrl","html","recindex","recindexReg","url","mediarecindex","mediaUrl","mediarecindexReg","posterUrl","fileposMatch","css","resolveHref","hrefmatch","fileposNum","selector","destroy","revokeObjectURL","clear"],"sourceRoot":""}